<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WhitespaceAroundCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.whitespace</a> &gt; <span class="el_source">WhitespaceAroundCheck.java</span></div><h1>WhitespaceAroundCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2020 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.whitespace;

import com.puppycrawl.tools.checkstyle.StatelessCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

/**
 * &lt;p&gt;
 * Checks that a token is surrounded by whitespace. Empty constructor,
 * method, class, enum, interface, loop bodies (blocks), lambdas of the form
 * &lt;/p&gt;
 * &lt;pre&gt;
 * public MyClass() {}      // empty constructor
 * public void func() {}    // empty method
 * public interface Foo {} // empty interface
 * public class Foo {} // empty class
 * public enum Foo {} // empty enum
 * MyClass c = new MyClass() {}; // empty anonymous class
 * while (i = 1) {} // empty while loop
 * for (int i = 1; i &amp;gt; 1; i++) {} // empty for loop
 * do {} while (i = 1); // empty do-while loop
 * Runnable noop = () -&amp;gt; {}; // empty lambda
 * public @interface Beta {} // empty annotation type
 * &lt;/pre&gt;
 * &lt;p&gt;
 * may optionally be exempted from the policy using the {@code allowEmptyMethods},
 * {@code allowEmptyConstructors}, {@code allowEmptyTypes}, {@code allowEmptyLoops},
 * {@code allowEmptyLambdas} and {@code allowEmptyCatches} properties.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This check does not flag as violation double brace initialization like:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * new Properties() {{
 *     setProperty(&quot;key&quot;, &quot;value&quot;);
 * }};
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Parameter allowEmptyCatches allows to suppress violations when token list
 * contains SLIST to check if beginning of block is surrounded by whitespace
 * and catch block is empty, for example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * try {
 *     k = 5 / i;
 * } catch (ArithmeticException ex) {}
 * &lt;/pre&gt;
 * &lt;p&gt;
 * With this property turned off, this raises violation because the beginning
 * of the catch block (left curly bracket) is not separated from the end
 * of the catch block (right curly bracket).
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * Property {@code allowEmptyConstructors} - Allow empty constructor bodies.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowEmptyMethods} - Allow empty method bodies.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowEmptyTypes} - Allow empty class, interface and enum bodies.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowEmptyLoops} - Allow empty loop bodies.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowEmptyLambdas} - Allow empty lambda bodies.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowEmptyCatches} - Allow empty catch bodies.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code ignoreEnhancedForColon} - Ignore whitespace around colon in
 * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2&quot;&gt;
 * enhanced for&lt;/a&gt; loop.
 * Default value is {@code true}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code tokens} - tokens to check Default value is:
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ASSIGN&quot;&gt;
 * ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BAND&quot;&gt;
 * BAND&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BAND_ASSIGN&quot;&gt;
 * BAND_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BOR&quot;&gt;
 * BOR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BOR_ASSIGN&quot;&gt;
 * BOR_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BSR&quot;&gt;
 * BSR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BSR_ASSIGN&quot;&gt;
 * BSR_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BXOR&quot;&gt;
 * BXOR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#BXOR_ASSIGN&quot;&gt;
 * BXOR_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#COLON&quot;&gt;
 * COLON&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#DIV&quot;&gt;
 * DIV&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#DIV_ASSIGN&quot;&gt;
 * DIV_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#DO_WHILE&quot;&gt;
 * DO_WHILE&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#EQUAL&quot;&gt;
 * EQUAL&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#GE&quot;&gt;
 * GE&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#GT&quot;&gt;
 * GT&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LAMBDA&quot;&gt;
 * LAMBDA&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LAND&quot;&gt;
 * LAND&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LCURLY&quot;&gt;
 * LCURLY&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LE&quot;&gt;
 * LE&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_CATCH&quot;&gt;
 * LITERAL_CATCH&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_DO&quot;&gt;
 * LITERAL_DO&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_ELSE&quot;&gt;
 * LITERAL_ELSE&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_FINALLY&quot;&gt;
 * LITERAL_FINALLY&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_FOR&quot;&gt;
 * LITERAL_FOR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_IF&quot;&gt;
 * LITERAL_IF&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_RETURN&quot;&gt;
 * LITERAL_RETURN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_SWITCH&quot;&gt;
 * LITERAL_SWITCH&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_SYNCHRONIZED&quot;&gt;
 * LITERAL_SYNCHRONIZED&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_TRY&quot;&gt;
 * LITERAL_TRY&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_WHILE&quot;&gt;
 * LITERAL_WHILE&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LOR&quot;&gt;
 * LOR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LT&quot;&gt;
 * LT&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#MINUS&quot;&gt;
 * MINUS&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#MINUS_ASSIGN&quot;&gt;
 * MINUS_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#MOD&quot;&gt;
 * MOD&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#MOD_ASSIGN&quot;&gt;
 * MOD_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#NOT_EQUAL&quot;&gt;
 * NOT_EQUAL&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#PLUS&quot;&gt;
 * PLUS&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#PLUS_ASSIGN&quot;&gt;
 * PLUS_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#QUESTION&quot;&gt;
 * QUESTION&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#RCURLY&quot;&gt;
 * RCURLY&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SL&quot;&gt;
 * SL&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SLIST&quot;&gt;
 * SLIST&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SL_ASSIGN&quot;&gt;
 * SL_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SR&quot;&gt;
 * SR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SR_ASSIGN&quot;&gt;
 * SR_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#STAR&quot;&gt;
 * STAR&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#STAR_ASSIGN&quot;&gt;
 * STAR_ASSIGN&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_ASSERT&quot;&gt;
 * LITERAL_ASSERT&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#TYPE_EXTENSION_AND&quot;&gt;
 * TYPE_EXTENSION_AND&lt;/a&gt;.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;To configure the check:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;/&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;To configure the check for whitespace only around
 * assignment operators:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;tokens&amp;quot;
 *     value=&amp;quot;ASSIGN,DIV_ASSIGN,PLUS_ASSIGN,MINUS_ASSIGN,STAR_ASSIGN,
 *            MOD_ASSIGN,SR_ASSIGN,BSR_ASSIGN,SL_ASSIGN,BXOR_ASSIGN,
 *            BOR_ASSIGN,BAND_ASSIGN&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;To configure the check for whitespace only around curly braces:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;tokens&amp;quot; value=&amp;quot;LCURLY,RCURLY&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to allow empty method bodies:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowEmptyMethods&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to allow empty constructor bodies:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowEmptyConstructors&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to allow empty type bodies:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowEmptyTypes&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to allow empty loop bodies:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowEmptyLoops&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to allow empty lambda bodies:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowEmptyLambdas&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to allow empty catch bodies:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowEmptyCatches&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Also, this check can be configured to ignore the colon in an enhanced for
 * loop. The colon in an enhanced for loop is ignored by default.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To configure the check to ignore the colon:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;WhitespaceAround&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;ignoreEnhancedForColon&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 *
 * @since 3.0
 */
@StatelessCheck
<span class="fc" id="L298">public class WhitespaceAroundCheck extends AbstractCheck {</span>

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_WS_NOT_PRECEDED = &quot;ws.notPreceded&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_WS_NOT_FOLLOWED = &quot;ws.notFollowed&quot;;

    /** Allow empty constructor bodies. */
    private boolean allowEmptyConstructors;
    /** Allow empty method bodies. */
    private boolean allowEmptyMethods;
    /** Allow empty class, interface and enum bodies. */
    private boolean allowEmptyTypes;
    /** Allow empty loop bodies. */
    private boolean allowEmptyLoops;
    /** Allow empty lambda bodies. */
    private boolean allowEmptyLambdas;
    /** Allow empty catch bodies. */
    private boolean allowEmptyCatches;
    /**
     * Ignore whitespace around colon in
     * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2&quot;&gt;
     * enhanced for&lt;/a&gt; loop.
     */
<span class="fc" id="L329">    private boolean ignoreEnhancedForColon = true;</span>

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L333">        return new int[] {</span>
            TokenTypes.ASSIGN,
            TokenTypes.BAND,
            TokenTypes.BAND_ASSIGN,
            TokenTypes.BOR,
            TokenTypes.BOR_ASSIGN,
            TokenTypes.BSR,
            TokenTypes.BSR_ASSIGN,
            TokenTypes.BXOR,
            TokenTypes.BXOR_ASSIGN,
            TokenTypes.COLON,
            TokenTypes.DIV,
            TokenTypes.DIV_ASSIGN,
            TokenTypes.DO_WHILE,
            TokenTypes.EQUAL,
            TokenTypes.GE,
            TokenTypes.GT,
            TokenTypes.LAMBDA,
            TokenTypes.LAND,
            TokenTypes.LCURLY,
            TokenTypes.LE,
            TokenTypes.LITERAL_CATCH,
            TokenTypes.LITERAL_DO,
            TokenTypes.LITERAL_ELSE,
            TokenTypes.LITERAL_FINALLY,
            TokenTypes.LITERAL_FOR,
            TokenTypes.LITERAL_IF,
            TokenTypes.LITERAL_RETURN,
            TokenTypes.LITERAL_SWITCH,
            TokenTypes.LITERAL_SYNCHRONIZED,
            TokenTypes.LITERAL_TRY,
            TokenTypes.LITERAL_WHILE,
            TokenTypes.LOR,
            TokenTypes.LT,
            TokenTypes.MINUS,
            TokenTypes.MINUS_ASSIGN,
            TokenTypes.MOD,
            TokenTypes.MOD_ASSIGN,
            TokenTypes.NOT_EQUAL,
            TokenTypes.PLUS,
            TokenTypes.PLUS_ASSIGN,
            TokenTypes.QUESTION,
            TokenTypes.RCURLY,
            TokenTypes.SL,
            TokenTypes.SLIST,
            TokenTypes.SL_ASSIGN,
            TokenTypes.SR,
            TokenTypes.SR_ASSIGN,
            TokenTypes.STAR,
            TokenTypes.STAR_ASSIGN,
            TokenTypes.LITERAL_ASSERT,
            TokenTypes.TYPE_EXTENSION_AND,
        };
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L390">        return new int[] {</span>
            TokenTypes.ASSIGN,
            TokenTypes.ARRAY_INIT,
            TokenTypes.BAND,
            TokenTypes.BAND_ASSIGN,
            TokenTypes.BOR,
            TokenTypes.BOR_ASSIGN,
            TokenTypes.BSR,
            TokenTypes.BSR_ASSIGN,
            TokenTypes.BXOR,
            TokenTypes.BXOR_ASSIGN,
            TokenTypes.COLON,
            TokenTypes.DIV,
            TokenTypes.DIV_ASSIGN,
            TokenTypes.DO_WHILE,
            TokenTypes.EQUAL,
            TokenTypes.GE,
            TokenTypes.GT,
            TokenTypes.LAMBDA,
            TokenTypes.LAND,
            TokenTypes.LCURLY,
            TokenTypes.LE,
            TokenTypes.LITERAL_CATCH,
            TokenTypes.LITERAL_DO,
            TokenTypes.LITERAL_ELSE,
            TokenTypes.LITERAL_FINALLY,
            TokenTypes.LITERAL_FOR,
            TokenTypes.LITERAL_IF,
            TokenTypes.LITERAL_RETURN,
            TokenTypes.LITERAL_SWITCH,
            TokenTypes.LITERAL_SYNCHRONIZED,
            TokenTypes.LITERAL_TRY,
            TokenTypes.LITERAL_WHILE,
            TokenTypes.LOR,
            TokenTypes.LT,
            TokenTypes.MINUS,
            TokenTypes.MINUS_ASSIGN,
            TokenTypes.MOD,
            TokenTypes.MOD_ASSIGN,
            TokenTypes.NOT_EQUAL,
            TokenTypes.PLUS,
            TokenTypes.PLUS_ASSIGN,
            TokenTypes.QUESTION,
            TokenTypes.RCURLY,
            TokenTypes.SL,
            TokenTypes.SLIST,
            TokenTypes.SL_ASSIGN,
            TokenTypes.SR,
            TokenTypes.SR_ASSIGN,
            TokenTypes.STAR,
            TokenTypes.STAR_ASSIGN,
            TokenTypes.LITERAL_ASSERT,
            TokenTypes.TYPE_EXTENSION_AND,
            TokenTypes.WILDCARD_TYPE,
            TokenTypes.GENERIC_START,
            TokenTypes.GENERIC_END,
            TokenTypes.ELLIPSIS,
        };
    }

    @Override
    public int[] getRequiredTokens() {
<span class="fc" id="L452">        return CommonUtil.EMPTY_INT_ARRAY;</span>
    }

    /**
     * Setter to allow empty method bodies.
     * @param allow {@code true} to allow empty method bodies.
     */
    public void setAllowEmptyMethods(boolean allow) {
<span class="fc" id="L460">        allowEmptyMethods = allow;</span>
<span class="fc" id="L461">    }</span>

    /**
     * Setter to allow empty constructor bodies.
     * @param allow {@code true} to allow empty constructor bodies.
     */
    public void setAllowEmptyConstructors(boolean allow) {
<span class="fc" id="L468">        allowEmptyConstructors = allow;</span>
<span class="fc" id="L469">    }</span>

    /**
     * Setter to ignore whitespace around colon in
     * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.14.2&quot;&gt;
     * enhanced for&lt;/a&gt; loop.
     * @param ignore {@code true} to ignore enhanced for colon.
     */
    public void setIgnoreEnhancedForColon(boolean ignore) {
<span class="fc" id="L478">        ignoreEnhancedForColon = ignore;</span>
<span class="fc" id="L479">    }</span>

    /**
     * Setter to allow empty class, interface and enum bodies.
     * @param allow {@code true} to allow empty type bodies.
     */
    public void setAllowEmptyTypes(boolean allow) {
<span class="fc" id="L486">        allowEmptyTypes = allow;</span>
<span class="fc" id="L487">    }</span>

    /**
     * Setter to allow empty loop bodies.
     * @param allow {@code true} to allow empty loops bodies.
     */
    public void setAllowEmptyLoops(boolean allow) {
<span class="fc" id="L494">        allowEmptyLoops = allow;</span>
<span class="fc" id="L495">    }</span>

    /**
     * Setter to allow empty lambda bodies.
     * @param allow {@code true} to allow empty lambda expressions.
     */
    public void setAllowEmptyLambdas(boolean allow) {
<span class="fc" id="L502">        allowEmptyLambdas = allow;</span>
<span class="fc" id="L503">    }</span>

    /**
     * Setter to allow empty catch bodies.
     * @param allow {@code true} to allow empty catch blocks.
     */
    public void setAllowEmptyCatches(boolean allow) {
<span class="fc" id="L510">        allowEmptyCatches = allow;</span>
<span class="fc" id="L511">    }</span>

    @Override
    public void visitToken(DetailAST ast) {
<span class="fc" id="L515">        final int currentType = ast.getType();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (!isNotRelevantSituation(ast, currentType)) {</span>
<span class="fc" id="L517">            final String line = getLine(ast.getLineNo() - 1);</span>
<span class="fc" id="L518">            final int before = ast.getColumnNo() - 1;</span>
<span class="fc" id="L519">            final int after = ast.getColumnNo() + ast.getText().length();</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (before &gt;= 0) {</span>
<span class="fc" id="L522">                final char prevChar = line.charAt(before);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">                if (shouldCheckSeparationFromPreviousToken(ast)</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                        &amp;&amp; !Character.isWhitespace(prevChar)) {</span>
<span class="fc" id="L525">                    log(ast, MSG_WS_NOT_PRECEDED, ast.getText());</span>
                }
            }

<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (after &lt; line.length()) {</span>
<span class="fc" id="L530">                final char nextChar = line.charAt(after);</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">                if (shouldCheckSeparationFromNextToken(ast, nextChar)</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                        &amp;&amp; !Character.isWhitespace(nextChar)) {</span>
<span class="fc" id="L533">                    log(ast, MSG_WS_NOT_FOLLOWED, ast.getText());</span>
                }
            }
        }
<span class="fc" id="L537">    }</span>

    /**
     * Is ast not a target of Check.
     * @param ast ast
     * @param currentType type of ast
     * @return true is ok to skip validation
     */
    private boolean isNotRelevantSituation(DetailAST ast, int currentType) {
<span class="fc" id="L546">        final int parentType = ast.getParent().getType();</span>
<span class="fc bfc" id="L547" title="All 4 branches covered.">        final boolean starImport = currentType == TokenTypes.STAR</span>
                &amp;&amp; parentType == TokenTypes.DOT;
<span class="fc bfc" id="L549" title="All 2 branches covered.">        final boolean insideCaseGroup = parentType == TokenTypes.CASE_GROUP;</span>

<span class="fc bfc" id="L551" title="All 4 branches covered.">        final boolean starImportOrSlistInsideCaseGroup = starImport || insideCaseGroup;</span>
<span class="fc" id="L552">        final boolean colonOfCaseOrDefaultOrForEach =</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                isColonOfCaseOrDefault(parentType)</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                        || isColonOfForEach(parentType);</span>
<span class="fc" id="L555">        final boolean emptyBlockOrType =</span>
<span class="fc bfc" id="L556" title="All 4 branches covered.">                isEmptyBlock(ast, parentType)</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                    || allowEmptyTypes &amp;&amp; isEmptyType(ast);</span>

<span class="fc bfc" id="L559" title="All 6 branches covered.">        return starImportOrSlistInsideCaseGroup</span>
                || colonOfCaseOrDefaultOrForEach
                || emptyBlockOrType
<span class="fc bfc" id="L562" title="All 2 branches covered.">                || isArrayInitialization(currentType, parentType);</span>
    }

    /**
     * Check if it should be checked if previous token is separated from current by
     * whitespace.
     * This function is needed to recognise double brace initialization as valid,
     * unfortunately its not possible to implement this functionality
     * in isNotRelevantSituation method, because in this method when we return
     * true(is not relevant) ast is later doesn't check at all. For example:
     * new Properties() {{setProperty(&quot;double curly braces&quot;, &quot;are not a style violation&quot;);
     * }};
     * For second left curly brace in first line when we would return true from
     * isNotRelevantSituation it wouldn't later check that the next token(setProperty)
     * is not separated from previous token.
     * @param ast current AST.
     * @return true if it should be checked if previous token is separated by whitespace,
     *      false otherwise.
     */
    private static boolean shouldCheckSeparationFromPreviousToken(DetailAST ast) {
<span class="fc bfc" id="L582" title="All 2 branches covered.">        return !isPartOfDoubleBraceInitializerForPreviousToken(ast);</span>
    }

    /**
     * Check if it should be checked if next token is separated from current by
     * whitespace. Explanation why this method is needed is identical to one
     * included in shouldCheckSeparationFromPreviousToken method.
     * @param ast current AST.
     * @param nextChar next character.
     * @return true if it should be checked if next token is separated by whitespace,
     *      false otherwise.
     */
    private static boolean shouldCheckSeparationFromNextToken(DetailAST ast, char nextChar) {
<span class="fc bfc" id="L595" title="All 2 branches covered.">        return !(ast.getType() == TokenTypes.LITERAL_RETURN</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                    &amp;&amp; ast.getFirstChild().getType() == TokenTypes.SEMI)</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">                &amp;&amp; ast.getType() != TokenTypes.ARRAY_INIT</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                &amp;&amp; !isAnonymousInnerClassEnd(ast.getType(), nextChar)</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                &amp;&amp; !isPartOfDoubleBraceInitializerForNextToken(ast);</span>
    }

    /**
     * Check for &quot;})&quot; or &quot;};&quot; or &quot;},&quot;. Happens with anon-inners
     * @param currentType token
     * @param nextChar next symbol
     * @return true is that is end of anon inner class
     */
    private static boolean isAnonymousInnerClassEnd(int currentType, char nextChar) {
<span class="fc bfc" id="L609" title="All 10 branches covered.">        return currentType == TokenTypes.RCURLY</span>
                &amp;&amp; (nextChar == ')'
                        || nextChar == ';'
                        || nextChar == ','
                        || nextChar == '.');
    }

    /**
     * Is empty block.
     * @param ast ast
     * @param parentType parent
     * @return true is block is empty
     */
    private boolean isEmptyBlock(DetailAST ast, int parentType) {
<span class="fc bfc" id="L623" title="All 2 branches covered.">        return isEmptyMethodBlock(ast, parentType)</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">                || isEmptyCtorBlock(ast, parentType)</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                || isEmptyLoop(ast, parentType)</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">                || isEmptyLambda(ast, parentType)</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">                || isEmptyCatch(ast, parentType);</span>
    }

    /**
     * Tests if a given {@code DetailAST} is part of an empty block.
     * An example empty block might look like the following
     * &lt;p&gt;
     * &lt;pre&gt;   public void myMethod(int val) {}&lt;/pre&gt;
     * &lt;/p&gt;
     * In the above, the method body is an empty block (&quot;{}&quot;).
     *
     * @param ast the {@code DetailAST} to test.
     * @param parentType the token type of {@code ast}'s parent.
     * @param match the parent token type we're looking to match.
     * @return {@code true} if {@code ast} makes up part of an
     *         empty block contained under a {@code match} token type
     *         node.
     */
    private static boolean isEmptyBlock(DetailAST ast, int parentType, int match) {
        final boolean result;
<span class="fc" id="L647">        final int type = ast.getType();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">        if (type == TokenTypes.RCURLY) {</span>
<span class="fc" id="L649">            final DetailAST parent = ast.getParent();</span>
<span class="fc" id="L650">            final DetailAST grandParent = ast.getParent().getParent();</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">            result = parent.getFirstChild().getType() == TokenTypes.RCURLY</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">                    &amp;&amp; grandParent.getType() == match;</span>
<span class="fc" id="L653">        }</span>
        else {
<span class="fc bfc" id="L655" title="All 4 branches covered.">            result = type == TokenTypes.SLIST</span>
                &amp;&amp; parentType == match
<span class="fc bfc" id="L657" title="All 2 branches covered.">                &amp;&amp; ast.getFirstChild().getType() == TokenTypes.RCURLY;</span>
        }
<span class="fc" id="L659">        return result;</span>
    }

    /**
     * Whether colon belongs to cases or defaults.
     * @param parentType parent
     * @return true if current token in colon of case or default tokens
     */
    private static boolean isColonOfCaseOrDefault(int parentType) {
<span class="fc bfc" id="L668" title="All 4 branches covered.">        return parentType == TokenTypes.LITERAL_DEFAULT</span>
                    || parentType == TokenTypes.LITERAL_CASE;
    }

    /**
     * Whether colon belongs to for-each.
     * @param parentType parent
     * @return true if current token in colon of for-each token
     */
    private boolean isColonOfForEach(int parentType) {
<span class="fc bfc" id="L678" title="All 4 branches covered.">        return parentType == TokenTypes.FOR_EACH_CLAUSE</span>
                &amp;&amp; ignoreEnhancedForColon;
    }

    /**
     * Is array initialization.
     * @param currentType current token
     * @param parentType parent token
     * @return true is current token inside array initialization
     */
    private static boolean isArrayInitialization(int currentType, int parentType) {
<span class="fc bfc" id="L689" title="All 6 branches covered.">        return currentType == TokenTypes.RCURLY</span>
                &amp;&amp; (parentType == TokenTypes.ARRAY_INIT
                        || parentType == TokenTypes.ANNOTATION_ARRAY_INIT);
    }

    /**
     * Test if the given {@code DetailAST} is part of an allowed empty
     * method block.
     * @param ast the {@code DetailAST} to test.
     * @param parentType the token type of {@code ast}'s parent.
     * @return {@code true} if {@code ast} makes up part of an
     *         allowed empty method block.
     */
    private boolean isEmptyMethodBlock(DetailAST ast, int parentType) {
<span class="fc bfc" id="L703" title="All 2 branches covered.">        return allowEmptyMethods</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                &amp;&amp; isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);</span>
    }

    /**
     * Test if the given {@code DetailAST} is part of an allowed empty
     * constructor (ctor) block.
     * @param ast the {@code DetailAST} to test.
     * @param parentType the token type of {@code ast}'s parent.
     * @return {@code true} if {@code ast} makes up part of an
     *         allowed empty constructor block.
     */
    private boolean isEmptyCtorBlock(DetailAST ast, int parentType) {
<span class="fc bfc" id="L716" title="All 2 branches covered.">        return allowEmptyConstructors</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                &amp;&amp; isEmptyBlock(ast, parentType, TokenTypes.CTOR_DEF);</span>
    }

    /**
     * Checks if loop is empty.
     * @param ast ast the {@code DetailAST} to test.
     * @param parentType the token type of {@code ast}'s parent.
     * @return {@code true} if {@code ast} makes up part of an
     *         allowed empty loop block.
     */
    private boolean isEmptyLoop(DetailAST ast, int parentType) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        return allowEmptyLoops</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                &amp;&amp; (isEmptyBlock(ast, parentType, TokenTypes.LITERAL_FOR)</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">                        || isEmptyBlock(ast, parentType, TokenTypes.LITERAL_WHILE)</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                        || isEmptyBlock(ast, parentType, TokenTypes.LITERAL_DO));</span>
    }

    /**
     * Test if the given {@code DetailAST} is part of an allowed empty
     * lambda block.
     * @param ast the {@code DetailAST} to test.
     * @param parentType the token type of {@code ast}'s parent.
     * @return {@code true} if {@code ast} makes up part of an
     *         allowed empty lambda block.
     */
    private boolean isEmptyLambda(DetailAST ast, int parentType) {
<span class="fc bfc" id="L743" title="All 4 branches covered.">        return allowEmptyLambdas &amp;&amp; isEmptyBlock(ast, parentType, TokenTypes.LAMBDA);</span>
    }

    /**
     * Tests if the given {@code DetailAst} is part of an allowed empty
     * catch block.
     * @param ast the {@code DetailAst} to test.
     * @param parentType the token type of {@code ast}'s parent
     * @return {@code true} if {@code ast} makes up part of an
     *         allowed empty catch block.
     */
    private boolean isEmptyCatch(DetailAST ast, int parentType) {
<span class="fc bfc" id="L755" title="All 4 branches covered.">        return allowEmptyCatches &amp;&amp; isEmptyBlock(ast, parentType, TokenTypes.LITERAL_CATCH);</span>
    }

    /**
     * Test if the given {@code DetailAST} is part of an empty block.
     * An example empty block might look like the following
     * &lt;p&gt;
     * &lt;pre&gt;   class Foo {}&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * @param ast ast the {@code DetailAST} to test.
     * @return {@code true} if {@code ast} makes up part of an
     *         empty block contained under a {@code match} token type
     *         node.
     */
    private static boolean isEmptyType(DetailAST ast) {
<span class="fc" id="L771">        final int type = ast.getType();</span>
<span class="fc" id="L772">        final DetailAST nextSibling = ast.getNextSibling();</span>
<span class="fc" id="L773">        final DetailAST previousSibling = ast.getPreviousSibling();</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        return type == TokenTypes.LCURLY</span>
<span class="fc bfc" id="L775" title="All 4 branches covered.">                    &amp;&amp; nextSibling.getType() == TokenTypes.RCURLY</span>
                || previousSibling != null
<span class="fc bfc" id="L777" title="All 2 branches covered.">                    &amp;&amp; previousSibling.getType() == TokenTypes.LCURLY;</span>
    }

    /**
     * Check if given ast is part of double brace initializer and if it
     * should omit checking if previous token is separated by whitespace.
     * @param ast ast to check
     * @return true if it should omit checking for previous token, false otherwise
     */
    private static boolean isPartOfDoubleBraceInitializerForPreviousToken(DetailAST ast) {
<span class="fc" id="L787">        final boolean initializerBeginsAfterClassBegins =</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">                ast.getParent().getType() == TokenTypes.INSTANCE_INIT;</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        final boolean classEndsAfterInitializerEnds = ast.getPreviousSibling() != null</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                &amp;&amp; ast.getPreviousSibling().getType() == TokenTypes.INSTANCE_INIT;</span>
<span class="fc bfc" id="L791" title="All 4 branches covered.">        return initializerBeginsAfterClassBegins || classEndsAfterInitializerEnds;</span>
    }

    /**
     * Check if given ast is part of double brace initializer and if it
     * should omit checking if next token is separated by whitespace.
     * See &lt;a href=&quot;https://github.com/checkstyle/checkstyle/pull/2845&quot;&gt;
     * PR#2845&lt;/a&gt; for more information why this function was needed.
     * @param ast ast to check
     * @return true if it should omit checking for next token, false otherwise
     */
    private static boolean isPartOfDoubleBraceInitializerForNextToken(DetailAST ast) {
<span class="fc bfc" id="L803" title="All 2 branches covered.">        final boolean classBeginBeforeInitializerBegin = ast.getType() == TokenTypes.LCURLY</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">            &amp;&amp; ast.getNextSibling().getType() == TokenTypes.INSTANCE_INIT;</span>
<span class="fc" id="L805">        final boolean initializerEndsBeforeClassEnds =</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">            ast.getParent().getParent().getType() == TokenTypes.INSTANCE_INIT</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">            &amp;&amp; ast.getParent().getParent().getNextSibling().getType() == TokenTypes.RCURLY;</span>
<span class="fc bfc" id="L808" title="All 4 branches covered.">        return classBeginBeforeInitializerBegin || initializerEndsBeforeClassEnds;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>