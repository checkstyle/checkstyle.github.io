<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Main.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle</a> &gt; <span class="el_source">Main.java</span></div><h1>Main.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2018 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.logging.ConsoleHandler;
import java.util.logging.Filter;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.puppycrawl.tools.checkstyle.api.AuditEvent;
import com.puppycrawl.tools.checkstyle.api.AuditListener;
import com.puppycrawl.tools.checkstyle.api.AutomaticBean;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.Configuration;
import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
import com.puppycrawl.tools.checkstyle.api.RootModule;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

/**
 * Wrapper command line program for the Checker.
 * @noinspection UseOfSystemOutOrSystemErr
 **/
public final class Main {

    /**
     * A key pointing to the error counter
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String ERROR_COUNTER = &quot;Main.errorCounter&quot;;
    /**
     * A key pointing to the load properties exception
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String LOAD_PROPERTIES_EXCEPTION = &quot;Main.loadProperties&quot;;
    /**
     * A key pointing to the create listener exception
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String CREATE_LISTENER_EXCEPTION = &quot;Main.createListener&quot;;
    /** Logger for Main. */
<span class="fc" id="L79">    private static final Log LOG = LogFactory.getLog(Main.class);</span>

    /** Width of CLI help option. */
    private static final int HELP_WIDTH = 100;

    /** Exit code returned when execution finishes with {@link CheckstyleException}. */
    private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;

    /** Name for the option 'v'. */
    private static final String OPTION_V_NAME = &quot;v&quot;;

    /** Name for the option 'c'. */
    private static final String OPTION_C_NAME = &quot;c&quot;;

    /** Name for the option 'f'. */
    private static final String OPTION_F_NAME = &quot;f&quot;;

    /** Name for the option 'p'. */
    private static final String OPTION_P_NAME = &quot;p&quot;;

    /** Name for the option 'o'. */
    private static final String OPTION_O_NAME = &quot;o&quot;;

    /** Name for the option 's'. */
    private static final String OPTION_S_NAME = &quot;s&quot;;

    /** Name for the option 't'. */
    private static final String OPTION_T_NAME = &quot;t&quot;;

    /** Name for the option '--tree'. */
    private static final String OPTION_TREE_NAME = &quot;tree&quot;;

    /** Name for the option 'tabWidth'. */
    private static final String OPTION_TAB_WIDTH_NAME = &quot;tabWidth&quot;;

    /** Name for the option '-T'. */
    private static final String OPTION_CAPITAL_T_NAME = &quot;T&quot;;

    /** Name for the option '--treeWithComments'. */
    private static final String OPTION_TREE_COMMENT_NAME = &quot;treeWithComments&quot;;

    /** Name for the option '-j'. */
    private static final String OPTION_J_NAME = &quot;j&quot;;

    /** Name for the option '--javadocTree'. */
    private static final String OPTION_JAVADOC_TREE_NAME = &quot;javadocTree&quot;;

    /** Name for the option '-J'. */
    private static final String OPTION_CAPITAL_J_NAME = &quot;J&quot;;

    /** Name for the option '--treeWithJavadoc'. */
    private static final String OPTION_TREE_JAVADOC_NAME = &quot;treeWithJavadoc&quot;;

    /** Name for the option '-d'. */
    private static final String OPTION_D_NAME = &quot;d&quot;;

    /** Name for the option '--debug'. */
    private static final String OPTION_DEBUG_NAME = &quot;debug&quot;;

    /** Name for the option 'e'. */
    private static final String OPTION_E_NAME = &quot;e&quot;;

    /** Name for the option '--exclude'. */
    private static final String OPTION_EXCLUDE_NAME = &quot;exclude&quot;;

    /** Name for the option '--executeIgnoredModules'. */
    private static final String OPTION_EXECUTE_IGNORED_MODULES_NAME = &quot;executeIgnoredModules&quot;;

    /** Name for the option 'x'. */
    private static final String OPTION_X_NAME = &quot;x&quot;;

    /** Name for the option '--exclude-regexp'. */
    private static final String OPTION_EXCLUDE_REGEXP_NAME = &quot;exclude-regexp&quot;;

    /** Name for the option '-C'. */
    private static final String OPTION_CAPITAL_C_NAME = &quot;C&quot;;

    /** Name for the option '--checker-threads-number'. */
    private static final String OPTION_CHECKER_THREADS_NUMBER_NAME = &quot;checker-threads-number&quot;;

    /** Name for the option '-W'. */
    private static final String OPTION_CAPITAL_W_NAME = &quot;W&quot;;

    /** Name for the option '--tree-walker-threads-number'. */
    private static final String OPTION_TREE_WALKER_THREADS_NUMBER_NAME =
        &quot;tree-walker-threads-number&quot;;

    /** Name for the option 'gxs'. */
    private static final String OPTION_GXS_NAME = &quot;gxs&quot;;

    /** Name for the option 'generate-xpath-suppression'. */
    private static final String OPTION_GENERATE_XPATH_SUPPRESSION_NAME =
            &quot;generate-xpath-suppression&quot;;

    /** Name for 'xml' format. */
    private static final String XML_FORMAT_NAME = &quot;xml&quot;;

    /** Name for 'plain' format. */
    private static final String PLAIN_FORMAT_NAME = &quot;plain&quot;;

    /** A string value of 1. */
    private static final String ONE_STRING_VALUE = &quot;1&quot;;

    /** Default distance between tab stops. */
    private static final String DEFAULT_TAB_WIDTH = &quot;8&quot;;

    /** Don't create instance of this class, use {@link #main(String[])} method instead. */
    private Main() {
    }

    /**
     * Loops over the files specified checking them for errors. The exit code
     * is the number of errors found in all the files.
     * @param args the command line arguments.
     * @throws IOException if there is a problem with files access
     * @noinspection CallToPrintStackTrace, CallToSystemExit
     **/
    public static void main(String... args) throws IOException {
<span class="fc" id="L197">        int errorCounter = 0;</span>
<span class="fc" id="L198">        boolean cliViolations = false;</span>
        // provide proper exit code based on results.
<span class="fc" id="L200">        final int exitWithCliViolation = -1;</span>
<span class="fc" id="L201">        int exitStatus = 0;</span>

        try {
            //parse CLI arguments
<span class="fc" id="L205">            final CommandLine commandLine = parseCli(args);</span>

            // show version and exit if it is requested
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (commandLine.hasOption(OPTION_V_NAME)) {</span>
<span class="fc" id="L209">                System.out.println(&quot;Checkstyle version: &quot;</span>
<span class="fc" id="L210">                        + Main.class.getPackage().getImplementationVersion());</span>
<span class="fc" id="L211">                exitStatus = 0;</span>
            }
            else {
<span class="fc" id="L214">                final List&lt;File&gt; filesToProcess = getFilesToProcess(getExclusions(commandLine),</span>
<span class="fc" id="L215">                        commandLine.getArgs());</span>

                // return error if something is wrong in arguments
<span class="fc" id="L218">                final List&lt;String&gt; messages = validateCli(commandLine, filesToProcess);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                cliViolations = !messages.isEmpty();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (cliViolations) {</span>
<span class="fc" id="L221">                    exitStatus = exitWithCliViolation;</span>
<span class="fc" id="L222">                    errorCounter = 1;</span>
<span class="fc" id="L223">                    messages.forEach(System.out::println);</span>
                }
                else {
<span class="fc" id="L226">                    errorCounter = runCli(commandLine, filesToProcess);</span>
<span class="fc" id="L227">                    exitStatus = errorCounter;</span>
                }
            }
        }
<span class="fc" id="L231">        catch (ParseException pex) {</span>
            // something wrong with arguments - print error and manual
<span class="fc" id="L233">            cliViolations = true;</span>
<span class="fc" id="L234">            exitStatus = exitWithCliViolation;</span>
<span class="fc" id="L235">            errorCounter = 1;</span>
<span class="fc" id="L236">            System.out.println(pex.getMessage());</span>
<span class="fc" id="L237">            printUsage();</span>
        }
<span class="fc" id="L239">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L240">            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;</span>
<span class="fc" id="L241">            errorCounter = 1;</span>
<span class="fc" id="L242">            ex.printStackTrace();</span>
        }
        finally {
            // return exit code base on validation of Checker
            // two ifs exist till https://github.com/hcoles/pitest/issues/377
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (errorCounter != 0) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                if (!cliViolations) {</span>
<span class="fc" id="L249">                    final LocalizedMessage errorCounterMessage = new LocalizedMessage(0,</span>
                            Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,
<span class="fc" id="L251">                            new String[] {String.valueOf(errorCounter)}, null, Main.class, null);</span>
<span class="fc" id="L252">                    System.out.println(errorCounterMessage.getMessage());</span>
                }
            }
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (exitStatus != 0) {</span>
<span class="fc" id="L256">                System.exit(exitStatus);</span>
            }
        }
<span class="fc" id="L259">    }</span>

    /**
     * Parses and executes Checkstyle based on passed arguments.
     * @param args
     *        command line parameters
     * @return parsed information about passed parameters
     * @throws ParseException
     *         when passed arguments are not valid
     */
    private static CommandLine parseCli(String... args)
            throws ParseException {
        // parse the parameters
<span class="fc" id="L272">        final CommandLineParser clp = new DefaultParser();</span>
        // always returns not null value
<span class="fc" id="L274">        return clp.parse(buildOptions(), args);</span>
    }

    /**
     * Gets the list of exclusions provided through the command line argument.
     * @param commandLine command line object
     * @return List of exclusion patterns.
     */
    private static List&lt;Pattern&gt; getExclusions(CommandLine commandLine) {
<span class="fc" id="L283">        final List&lt;Pattern&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_E_NAME)) {</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            for (String value : commandLine.getOptionValues(OPTION_E_NAME)) {</span>
<span class="fc" id="L287">                result.add(Pattern.compile(&quot;^&quot; + Pattern.quote(new File(value).getAbsolutePath())</span>
                        + &quot;$&quot;));
            }
        }
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_X_NAME)) {</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            for (String value : commandLine.getOptionValues(OPTION_X_NAME)) {</span>
<span class="fc" id="L293">                result.add(Pattern.compile(value));</span>
            }
        }

<span class="fc" id="L297">        return result;</span>
    }

    /**
     * Do validation of Command line options.
     * @param cmdLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return list of violations
     */
    // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation
    private static List&lt;String&gt; validateCli(CommandLine cmdLine, List&lt;File&gt; filesToProcess) {
<span class="fc" id="L308">        final List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (filesToProcess.isEmpty()) {</span>
<span class="fc" id="L311">            result.add(&quot;Files to process must be specified, found 0.&quot;);</span>
        }
        // ensure there is no conflicting options
<span class="fc bfc" id="L314" title="All 4 branches covered.">        else if (cmdLine.hasOption(OPTION_T_NAME) || cmdLine.hasOption(OPTION_CAPITAL_T_NAME)</span>
<span class="fc bfc" id="L315" title="All 4 branches covered.">                || cmdLine.hasOption(OPTION_J_NAME) || cmdLine.hasOption(OPTION_CAPITAL_J_NAME)) {</span>
<span class="fc bfc" id="L316" title="All 4 branches covered.">            if (cmdLine.hasOption(OPTION_S_NAME) || cmdLine.hasOption(OPTION_C_NAME)</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">                    || cmdLine.hasOption(OPTION_P_NAME) || cmdLine.hasOption(OPTION_F_NAME)</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                    || cmdLine.hasOption(OPTION_O_NAME)) {</span>
<span class="fc" id="L319">                result.add(&quot;Option '-t' cannot be used with other options.&quot;);</span>
            }
<span class="fc bfc" id="L321" title="All 2 branches covered.">            else if (filesToProcess.size() &gt; 1) {</span>
<span class="fc" id="L322">                result.add(&quot;Printing AST is allowed for only one file.&quot;);</span>
            }
        }
<span class="fc bfc" id="L325" title="All 2 branches covered.">        else if (cmdLine.hasOption(OPTION_S_NAME)) {</span>
<span class="fc bfc" id="L326" title="All 4 branches covered.">            if (cmdLine.hasOption(OPTION_C_NAME) || cmdLine.hasOption(OPTION_P_NAME)</span>
<span class="fc bfc" id="L327" title="All 4 branches covered.">                    || cmdLine.hasOption(OPTION_F_NAME) || cmdLine.hasOption(OPTION_O_NAME)) {</span>
<span class="fc" id="L328">                result.add(&quot;Option '-s' cannot be used with other options.&quot;);</span>
            }
<span class="fc bfc" id="L330" title="All 2 branches covered.">            else if (filesToProcess.size() &gt; 1) {</span>
<span class="fc" id="L331">                result.add(&quot;Printing xpath suppressions is allowed for only one file.&quot;);</span>
            }
        }
        // ensure a configuration file is specified
<span class="fc bfc" id="L335" title="All 2 branches covered.">        else if (cmdLine.hasOption(OPTION_C_NAME)) {</span>
<span class="fc" id="L336">            final String configLocation = cmdLine.getOptionValue(OPTION_C_NAME);</span>
            try {
                // test location only
<span class="fc" id="L339">                CommonUtil.getUriByFilename(configLocation);</span>
            }
<span class="fc" id="L341">            catch (CheckstyleException ignored) {</span>
<span class="fc" id="L342">                result.add(String.format(&quot;Could not find config XML file '%s'.&quot;, configLocation));</span>
<span class="fc" id="L343">            }</span>

            // validate optional parameters
<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (cmdLine.hasOption(OPTION_F_NAME)) {</span>
<span class="fc" id="L347">                final String format = cmdLine.getOptionValue(OPTION_F_NAME);</span>
<span class="fc bfc" id="L348" title="All 4 branches covered.">                if (!PLAIN_FORMAT_NAME.equals(format) &amp;&amp; !XML_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L349">                    result.add(String.format(&quot;Invalid output format.&quot;</span>
                            + &quot; Found '%s' but expected '%s' or '%s'.&quot;,
                            format, PLAIN_FORMAT_NAME, XML_FORMAT_NAME));
                }
            }
<span class="fc bfc" id="L354" title="All 2 branches covered.">            if (cmdLine.hasOption(OPTION_P_NAME)) {</span>
<span class="fc" id="L355">                final String propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);</span>
<span class="fc" id="L356">                final File file = new File(propertiesLocation);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">                if (!file.exists()) {</span>
<span class="fc" id="L358">                    result.add(String.format(&quot;Could not find file '%s'.&quot;, propertiesLocation));</span>
                }
            }
<span class="fc" id="L361">            verifyThreadsNumberParameter(cmdLine, result, OPTION_CAPITAL_C_NAME,</span>
                &quot;Checker threads number must be greater than zero&quot;,
                &quot;Invalid Checker threads number&quot;);
<span class="fc" id="L364">            verifyThreadsNumberParameter(cmdLine, result, OPTION_CAPITAL_W_NAME,</span>
                &quot;TreeWalker threads number must be greater than zero&quot;,
                &quot;Invalid TreeWalker threads number&quot;);
<span class="fc" id="L367">        }</span>
        else {
<span class="fc" id="L369">            result.add(&quot;Must specify a config XML file.&quot;);</span>
        }

<span class="fc" id="L372">        return result;</span>
    }

    /**
     * Verifies threads number CLI parameter value.
     * @param cmdLine a command line
     * @param result a resulting list of errors
     * @param cliParameterName a CLI parameter name
     * @param mustBeGreaterThanZeroMessage a message which should be reported
     *                                     if the number of threads is less than or equal to zero
     * @param invalidNumberMessage a message which should be reported if the passed value
     *                             is not a valid number
     */
    private static void verifyThreadsNumberParameter(CommandLine cmdLine, List&lt;String&gt; result,
        String cliParameterName, String mustBeGreaterThanZeroMessage,
        String invalidNumberMessage) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (cmdLine.hasOption(cliParameterName)) {</span>
<span class="fc" id="L389">            final String checkerThreadsNumberStr =</span>
<span class="fc" id="L390">                cmdLine.getOptionValue(cliParameterName);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if (CommonUtil.isInt(checkerThreadsNumberStr)) {</span>
<span class="fc" id="L392">                final int checkerThreadsNumber = Integer.parseInt(checkerThreadsNumberStr);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                if (checkerThreadsNumber &lt; 1) {</span>
<span class="fc" id="L394">                    result.add(mustBeGreaterThanZeroMessage);</span>
                }
<span class="fc" id="L396">            }</span>
            else {
<span class="fc" id="L398">                result.add(invalidNumberMessage);</span>
            }
        }
<span class="fc" id="L401">    }</span>

    /**
     * Do execution of CheckStyle based on Command line options.
     * @param commandLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return number of violations
     * @throws IOException if a file could not be read.
     * @throws CheckstyleException if something happens processing the files.
     */
    private static int runCli(CommandLine commandLine, List&lt;File&gt; filesToProcess)
            throws IOException, CheckstyleException {
<span class="fc" id="L413">        int result = 0;</span>

        // create config helper object
<span class="fc" id="L416">        final CliOptions config = convertCliToPojo(commandLine, filesToProcess);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_T_NAME)) {</span>
            // print AST
<span class="fc" id="L419">            final File file = config.files.get(0);</span>
<span class="fc" id="L420">            final String stringAst = AstTreeStringPrinter.printFileAst(file,</span>
                    JavaParser.Options.WITHOUT_COMMENTS);
<span class="fc" id="L422">            System.out.print(stringAst);</span>
<span class="fc" id="L423">        }</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {</span>
<span class="fc" id="L425">            final File file = config.files.get(0);</span>
<span class="fc" id="L426">            final String stringAst = AstTreeStringPrinter.printFileAst(file,</span>
                    JavaParser.Options.WITH_COMMENTS);
<span class="fc" id="L428">            System.out.print(stringAst);</span>
<span class="fc" id="L429">        }</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_J_NAME)) {</span>
<span class="fc" id="L431">            final File file = config.files.get(0);</span>
<span class="fc" id="L432">            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);</span>
<span class="fc" id="L433">            System.out.print(stringAst);</span>
<span class="fc" id="L434">        }</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {</span>
<span class="fc" id="L436">            final File file = config.files.get(0);</span>
<span class="fc" id="L437">            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);</span>
<span class="fc" id="L438">            System.out.print(stringAst);</span>
<span class="fc" id="L439">        }</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_S_NAME)) {</span>
<span class="fc" id="L441">            final File file = config.files.get(0);</span>
<span class="fc" id="L442">            final String suppressionLineColumnNumber = config.suppressionLineColumnNumber;</span>
<span class="fc" id="L443">            final int tabWidth = config.tabWidth;</span>
<span class="fc" id="L444">            final String stringSuppressions =</span>
<span class="fc" id="L445">                    SuppressionsStringPrinter.printSuppressions(file,</span>
                            suppressionLineColumnNumber, tabWidth);
<span class="fc" id="L447">            System.out.print(stringSuppressions);</span>
<span class="fc" id="L448">        }</span>
        else {
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (commandLine.hasOption(OPTION_D_NAME)) {</span>
<span class="fc" id="L451">                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();</span>
<span class="fc" id="L452">                final ConsoleHandler handler = new ConsoleHandler();</span>
<span class="fc" id="L453">                handler.setLevel(Level.FINEST);</span>
<span class="fc" id="L454">                handler.setFilter(new Filter() {</span>
<span class="fc" id="L455">                    private final String packageName = Main.class.getPackage().getName();</span>

                    @Override
                    public boolean isLoggable(LogRecord record) {
<span class="fc" id="L459">                        return record.getLoggerName().startsWith(packageName);</span>
                    }
                });
<span class="fc" id="L462">                parentLogger.addHandler(handler);</span>
<span class="fc" id="L463">                parentLogger.setLevel(Level.FINEST);</span>
            }
<span class="fc bfc" id="L465" title="All 2 branches covered.">            if (LOG.isDebugEnabled()) {</span>
<span class="fc" id="L466">                LOG.debug(&quot;Checkstyle debug logging enabled&quot;);</span>
<span class="fc" id="L467">                LOG.debug(&quot;Running Checkstyle with version: &quot;</span>
<span class="fc" id="L468">                        + Main.class.getPackage().getImplementationVersion());</span>
            }

            // run Checker
<span class="fc" id="L472">            result = runCheckstyle(config);</span>
        }

<span class="fc" id="L475">        return result;</span>
    }

    /**
     * Util method to convert CommandLine type to POJO object.
     * @param cmdLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return command line option as POJO object
     */
    private static CliOptions convertCliToPojo(CommandLine cmdLine, List&lt;File&gt; filesToProcess) {
<span class="fc" id="L485">        final CliOptions conf = new CliOptions();</span>
<span class="fc" id="L486">        conf.format = cmdLine.getOptionValue(OPTION_F_NAME);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (conf.format == null) {</span>
<span class="fc" id="L488">            conf.format = PLAIN_FORMAT_NAME;</span>
        }
<span class="fc" id="L490">        conf.outputLocation = cmdLine.getOptionValue(OPTION_O_NAME);</span>
<span class="fc" id="L491">        conf.configLocation = cmdLine.getOptionValue(OPTION_C_NAME);</span>
<span class="fc" id="L492">        conf.propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);</span>
<span class="fc" id="L493">        conf.suppressionLineColumnNumber = cmdLine.getOptionValue(OPTION_S_NAME);</span>
<span class="fc" id="L494">        conf.files = filesToProcess;</span>
<span class="fc" id="L495">        conf.executeIgnoredModules = cmdLine.hasOption(OPTION_EXECUTE_IGNORED_MODULES_NAME);</span>
<span class="fc" id="L496">        final String checkerThreadsNumber = cmdLine.getOptionValue(</span>
                OPTION_CAPITAL_C_NAME, ONE_STRING_VALUE);
<span class="fc" id="L498">        conf.checkerThreadsNumber = Integer.parseInt(checkerThreadsNumber);</span>
<span class="fc" id="L499">        final String treeWalkerThreadsNumber = cmdLine.getOptionValue(</span>
                OPTION_CAPITAL_W_NAME, ONE_STRING_VALUE);
<span class="fc" id="L501">        conf.treeWalkerThreadsNumber = Integer.parseInt(treeWalkerThreadsNumber);</span>
<span class="fc" id="L502">        final String tabWidth =</span>
<span class="fc" id="L503">                cmdLine.getOptionValue(OPTION_TAB_WIDTH_NAME, DEFAULT_TAB_WIDTH);</span>
<span class="fc" id="L504">        conf.tabWidth = Integer.parseInt(tabWidth);</span>
<span class="fc" id="L505">        conf.generateXpathSuppressionsFile =</span>
<span class="fc" id="L506">                cmdLine.hasOption(OPTION_GENERATE_XPATH_SUPPRESSION_NAME);</span>
<span class="fc" id="L507">        return conf;</span>
    }

    /**
     * Executes required Checkstyle actions based on passed parameters.
     * @param cliOptions
     *        pojo object that contains all options
     * @return number of violations of ERROR level
     * @throws IOException
     *         when output file could not be found
     * @throws CheckstyleException
     *         when properties file could not be loaded
     */
    private static int runCheckstyle(CliOptions cliOptions)
            throws CheckstyleException, IOException {
        // setup the properties
        final Properties props;

<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (cliOptions.propertiesLocation == null) {</span>
<span class="fc" id="L526">            props = System.getProperties();</span>
        }
        else {
<span class="fc" id="L529">            props = loadProperties(new File(cliOptions.propertiesLocation));</span>
        }

        // create a configuration
<span class="fc" id="L533">        final ThreadModeSettings multiThreadModeSettings =</span>
                new ThreadModeSettings(
<span class="fc" id="L535">                        cliOptions.checkerThreadsNumber, cliOptions.treeWalkerThreadsNumber);</span>

        final ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (cliOptions.executeIgnoredModules) {</span>
<span class="fc" id="L539">            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;</span>
        }
        else {
<span class="fc" id="L542">            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;</span>
        }

<span class="fc" id="L545">        final Configuration config = ConfigurationLoader.loadConfiguration(</span>
<span class="fc" id="L546">                cliOptions.configLocation, new PropertiesExpander(props),</span>
                ignoredModulesOptions, multiThreadModeSettings);

        // create RootModule object and run it
        final int errorCounter;
<span class="fc" id="L551">        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();</span>
<span class="fc" id="L552">        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);</span>

        try {
            final AuditListener listener;
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (cliOptions.generateXpathSuppressionsFile) {</span>
                // create filter to print generated xpath suppressions file
<span class="fc" id="L558">                final Configuration treeWalkerConfig = getTreeWalkerConfig(config);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                if (treeWalkerConfig != null) {</span>
<span class="fc" id="L560">                    final DefaultConfiguration moduleConfig =</span>
                            new DefaultConfiguration(
<span class="fc" id="L562">                                    XpathFileGeneratorAstFilter.class.getName());</span>
<span class="fc" id="L563">                    moduleConfig.addAttribute(OPTION_TAB_WIDTH_NAME,</span>
<span class="fc" id="L564">                            Integer.toString(cliOptions.tabWidth));</span>
<span class="fc" id="L565">                    ((DefaultConfiguration) treeWalkerConfig).addChild(moduleConfig);</span>
                }

<span class="fc" id="L568">                listener = new XpathFileGeneratorAuditListener(System.out,</span>
                        AutomaticBean.OutputStreamOptions.NONE);
<span class="fc" id="L570">            }</span>
            else {
<span class="fc" id="L572">                listener = createListener(cliOptions.format,</span>
<span class="fc" id="L573">                        cliOptions.outputLocation);</span>
            }

<span class="fc" id="L576">            rootModule.setModuleClassLoader(moduleClassLoader);</span>
<span class="fc" id="L577">            rootModule.configure(config);</span>
<span class="fc" id="L578">            rootModule.addListener(listener);</span>

            // run RootModule
<span class="fc" id="L581">            errorCounter = rootModule.process(cliOptions.files);</span>
        }
        finally {
<span class="fc" id="L584">            rootModule.destroy();</span>
        }

<span class="fc" id="L587">        return errorCounter;</span>
    }

    /**
     * Returns {@code TreeWalker} module configuration.
     * @param config The configuration object.
     * @return The {@code TreeWalker} module configuration.
     */
    private static Configuration getTreeWalkerConfig(Configuration config) {
<span class="fc" id="L596">        Configuration result = null;</span>

<span class="fc" id="L598">        final Configuration[] children = config.getChildren();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        for (Configuration child : children) {</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (&quot;TreeWalker&quot;.equals(child.getName())) {</span>
<span class="fc" id="L601">                result = child;</span>
<span class="fc" id="L602">                break;</span>
            }
        }
<span class="fc" id="L605">        return result;</span>
    }

    /**
     * Creates a new instance of the root module that will control and run
     * Checkstyle.
     * @param name The name of the module. This will either be a short name that
     *        will have to be found or the complete package name.
     * @param moduleClassLoader Class loader used to load the root module.
     * @return The new instance of the root module.
     * @throws CheckstyleException if no module can be instantiated from name
     */
    private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)
            throws CheckstyleException {
<span class="fc" id="L619">        final ModuleFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L620">                Checker.class.getPackage().getName(), moduleClassLoader);</span>

<span class="fc" id="L622">        return (RootModule) factory.createModule(name);</span>
    }

    /**
     * Loads properties from a File.
     * @param file
     *        the properties file
     * @return the properties in file
     * @throws CheckstyleException
     *         when could not load properties file
     */
    private static Properties loadProperties(File file)
            throws CheckstyleException {
<span class="fc" id="L635">        final Properties properties = new Properties();</span>

<span class="fc" id="L637">        try (InputStream stream = Files.newInputStream(file.toPath())) {</span>
<span class="fc" id="L638">            properties.load(stream);</span>
        }
<span class="fc" id="L640">        catch (final IOException ex) {</span>
<span class="fc" id="L641">            final LocalizedMessage loadPropertiesExceptionMessage = new LocalizedMessage(0,</span>
                    Definitions.CHECKSTYLE_BUNDLE, LOAD_PROPERTIES_EXCEPTION,
<span class="fc" id="L643">                    new String[] {file.getAbsolutePath()}, null, Main.class, null);</span>
<span class="fc" id="L644">            throw new CheckstyleException(loadPropertiesExceptionMessage.getMessage(), ex);</span>
<span class="fc" id="L645">        }</span>

<span class="fc" id="L647">        return properties;</span>
    }

    /**
     * This method creates in AuditListener an open stream for validation data, it must be closed by
     * {@link RootModule} (default implementation is {@link Checker}) by calling
     * {@link AuditListener#auditFinished(AuditEvent)}.
     * @param format format of the audit listener
     * @param outputLocation the location of output
     * @return a fresh new {@code AuditListener}
     * @exception IOException when provided output location is not found
     */
    private static AuditListener createListener(String format, String outputLocation)
            throws IOException {
        final AuditListener listener;
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (XML_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L663">            final OutputStream out = getOutputStream(outputLocation);</span>
<span class="fc" id="L664">            final AutomaticBean.OutputStreamOptions closeOutputStreamOption =</span>
<span class="fc" id="L665">                    getOutputStreamOptions(outputLocation);</span>
<span class="fc" id="L666">            listener = new XMLLogger(out, closeOutputStreamOption);</span>
<span class="fc" id="L667">        }</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        else if (PLAIN_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L669">            final OutputStream out = getOutputStream(outputLocation);</span>
<span class="fc" id="L670">            final AutomaticBean.OutputStreamOptions closeOutputStreamOption =</span>
<span class="fc" id="L671">                    getOutputStreamOptions(outputLocation);</span>
<span class="fc" id="L672">            listener = new DefaultLogger(out, closeOutputStreamOption);</span>
<span class="fc" id="L673">        }</span>
        else {
<span class="fc" id="L675">            final LocalizedMessage outputFormatExceptionMessage = new LocalizedMessage(0,</span>
                    Definitions.CHECKSTYLE_BUNDLE, CREATE_LISTENER_EXCEPTION,
                    new String[] {format, PLAIN_FORMAT_NAME, XML_FORMAT_NAME}, null,
                    Main.class, null);
<span class="fc" id="L679">            throw new IllegalStateException(outputFormatExceptionMessage.getMessage());</span>
        }

<span class="fc" id="L682">        return listener;</span>
    }

    /**
     * Create output stream or return System.out
     * @param outputLocation output location
     * @return output stream
     * @throws IOException might happen
     */
    @SuppressWarnings(&quot;resource&quot;)
    private static OutputStream getOutputStream(String outputLocation) throws IOException {
        final OutputStream result;
<span class="fc bfc" id="L694" title="All 2 branches covered.">        if (outputLocation == null) {</span>
<span class="fc" id="L695">            result = System.out;</span>
        }
        else {
<span class="fc" id="L698">            result = Files.newOutputStream(Paths.get(outputLocation));</span>
        }
<span class="fc" id="L700">        return result;</span>
    }

    /**
     * Create {@link AutomaticBean.OutputStreamOptions} for the given location.
     * @param outputLocation output location
     * @return output stream options
     */
    private static AutomaticBean.OutputStreamOptions getOutputStreamOptions(String outputLocation) {
        final AutomaticBean.OutputStreamOptions result;
<span class="fc bfc" id="L710" title="All 2 branches covered.">        if (outputLocation == null) {</span>
<span class="fc" id="L711">            result = AutomaticBean.OutputStreamOptions.NONE;</span>
        }
        else {
<span class="fc" id="L714">            result = AutomaticBean.OutputStreamOptions.CLOSE;</span>
        }
<span class="fc" id="L716">        return result;</span>
    }

    /**
     * Determines the files to process.
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @param filesToProcess
     *        arguments that were not processed yet but shall be
     * @return list of files to process
     */
    private static List&lt;File&gt; getFilesToProcess(List&lt;Pattern&gt; patternsToExclude,
            String... filesToProcess) {
<span class="fc" id="L728">        final List&lt;File&gt; files = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        for (String element : filesToProcess) {</span>
<span class="fc" id="L730">            files.addAll(listFiles(new File(element), patternsToExclude));</span>
        }

<span class="fc" id="L733">        return files;</span>
    }

    /**
     * Traverses a specified node looking for files to check. Found files are added to a specified
     * list. Subdirectories are also traversed.
     * @param node
     *        the node to process
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @return found files
     */
    private static List&lt;File&gt; listFiles(File node, List&lt;Pattern&gt; patternsToExclude) {
        // could be replaced with org.apache.commons.io.FileUtils.list() method
        // if only we add commons-io library
<span class="fc" id="L747">        final List&lt;File&gt; result = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (node.canRead()) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (node.isDirectory()) {</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">                if (!isDirectoryExcluded(node.getAbsolutePath(), patternsToExclude)) {</span>
<span class="fc" id="L752">                    final File[] files = node.listFiles();</span>
                    // listFiles() can return null, so we need to check it
<span class="fc bfc" id="L754" title="All 2 branches covered.">                    if (files != null) {</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">                        for (File element : files) {</span>
<span class="fc" id="L756">                            result.addAll(listFiles(element, patternsToExclude));</span>
                        }
                    }
<span class="fc" id="L759">                }</span>
            }
<span class="fc bfc" id="L761" title="All 2 branches covered.">            else if (node.isFile()) {</span>
<span class="fc" id="L762">                result.add(node);</span>
            }
        }
<span class="fc" id="L765">        return result;</span>
    }

    /**
     * Checks if a directory {@code path} should be excluded based on if it matches one of the
     * patterns supplied.
     * @param path The path of the directory to check
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @return True if the directory matches one of the patterns.
     */
    private static boolean isDirectoryExcluded(String path, List&lt;Pattern&gt; patternsToExclude) {
<span class="fc" id="L776">        boolean result = false;</span>

<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (Pattern pattern : patternsToExclude) {</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            if (pattern.matcher(path).find()) {</span>
<span class="fc" id="L780">                result = true;</span>
<span class="fc" id="L781">                break;</span>
            }
<span class="fc" id="L783">        }</span>

<span class="fc" id="L785">        return result;</span>
    }

    /** Prints the usage information. **/
    private static void printUsage() {
<span class="fc" id="L790">        final HelpFormatter formatter = new HelpFormatter();</span>
<span class="fc" id="L791">        formatter.setWidth(HELP_WIDTH);</span>
<span class="fc" id="L792">        formatter.printHelp(String.format(&quot;java %s [options] -c &lt;config.xml&gt; file...&quot;,</span>
<span class="fc" id="L793">                Main.class.getName()), buildOptions());</span>
<span class="fc" id="L794">    }</span>

    /**
     * Builds and returns list of parameters supported by cli Checkstyle.
     * @return available options
     */
    private static Options buildOptions() {
<span class="fc" id="L801">        final Options options = new Options();</span>
<span class="fc" id="L802">        options.addOption(OPTION_C_NAME, true, &quot;Sets the check configuration file to use.&quot;);</span>
<span class="fc" id="L803">        options.addOption(OPTION_O_NAME, true, &quot;Sets the output file. Defaults to stdout&quot;);</span>
<span class="fc" id="L804">        options.addOption(OPTION_P_NAME, true, &quot;Loads the properties file&quot;);</span>
<span class="fc" id="L805">        options.addOption(OPTION_S_NAME, true,</span>
                &quot;Print xpath suppressions at the file's line and column position. &quot;
                        + &quot;Argument is the line and column number (separated by a : ) in the file &quot;
                        + &quot;that the suppression should be generated for&quot;);
<span class="fc" id="L809">        options.addOption(OPTION_TAB_WIDTH_NAME, true,</span>
<span class="fc" id="L810">                String.format(&quot;Sets the length of the tab character. Used only with \&quot;-s\&quot; option. &quot;</span>
                        + &quot;Default value is %s&quot;,
                        DEFAULT_TAB_WIDTH));
<span class="fc" id="L813">        options.addOption(OPTION_GXS_NAME, OPTION_GENERATE_XPATH_SUPPRESSION_NAME, false,</span>
                &quot;Generates to output a suppression.xml to use to suppress all violations&quot;
                        + &quot; from user's config&quot;);
<span class="fc" id="L816">        options.addOption(OPTION_F_NAME, true, String.format(</span>
                &quot;Sets the output format. (%s|%s). Defaults to %s&quot;,
                PLAIN_FORMAT_NAME, XML_FORMAT_NAME, PLAIN_FORMAT_NAME));
<span class="fc" id="L819">        options.addOption(OPTION_V_NAME, false, &quot;Print product version and exit&quot;);</span>
<span class="fc" id="L820">        options.addOption(OPTION_T_NAME, OPTION_TREE_NAME, false,</span>
                &quot;Print Abstract Syntax Tree(AST) of the file&quot;);
<span class="fc" id="L822">        options.addOption(OPTION_CAPITAL_T_NAME, OPTION_TREE_COMMENT_NAME, false,</span>
                &quot;Print Abstract Syntax Tree(AST) of the file including comments&quot;);
<span class="fc" id="L824">        options.addOption(OPTION_J_NAME, OPTION_JAVADOC_TREE_NAME, false,</span>
                &quot;Print Parse tree of the Javadoc comment&quot;);
<span class="fc" id="L826">        options.addOption(OPTION_CAPITAL_J_NAME, OPTION_TREE_JAVADOC_NAME, false,</span>
                &quot;Print full Abstract Syntax Tree of the file&quot;);
<span class="fc" id="L828">        options.addOption(OPTION_D_NAME, OPTION_DEBUG_NAME, false,</span>
                &quot;Print all debug logging of CheckStyle utility&quot;);
<span class="fc" id="L830">        options.addOption(OPTION_E_NAME, OPTION_EXCLUDE_NAME, true,</span>
                &quot;Directory path to exclude from CheckStyle&quot;);
<span class="fc" id="L832">        options.addOption(OPTION_X_NAME, OPTION_EXCLUDE_REGEXP_NAME, true,</span>
                &quot;Regular expression of directory to exclude from CheckStyle&quot;);
<span class="fc" id="L834">        options.addOption(OPTION_EXECUTE_IGNORED_MODULES_NAME, false,</span>
                &quot;Allows ignored modules to be run.&quot;);
<span class="fc" id="L836">        options.addOption(OPTION_CAPITAL_C_NAME, OPTION_CHECKER_THREADS_NUMBER_NAME, true,</span>
                &quot;(experimental) The number of Checker threads (must be greater than zero)&quot;);
<span class="fc" id="L838">        options.addOption(OPTION_CAPITAL_W_NAME, OPTION_TREE_WALKER_THREADS_NUMBER_NAME, true,</span>
                &quot;(experimental) The number of TreeWalker threads (must be greater than zero)&quot;);
<span class="fc" id="L840">        return options;</span>
    }

    /** Helper structure to clear show what is required for Checker to run. **/
    private static class CliOptions {

        /** Properties file location. */
        private String propertiesLocation;
        /** Config file location. */
        private String configLocation;
        /** Output format. */
        private String format;
        /** Output file location. */
        private String outputLocation;
        /** List of file to validate. */
        private List&lt;File&gt; files;
        /** Switch whether to execute ignored modules or not. */
        private boolean executeIgnoredModules;
        /** The checker threads number. */
        private int checkerThreadsNumber;
        /** The tree walker threads number. */
        private int treeWalkerThreadsNumber;
        /** LineNo and columnNo for the suppression. */
        private String suppressionLineColumnNumber;
        /** Tab character length. */
        private int tabWidth;
        /** Switch whether to generate suppressions file or not. */
        private boolean generateXpathSuppressionsFile;

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>