<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavadocMethodCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.javadoc</a> &gt; <span class="el_source">JavadocMethodCheck.java</span></div><h1>JavadocMethodCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2018 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.javadoc;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FileContents;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.Scope;
import com.puppycrawl.tools.checkstyle.api.TextBlock;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;

/**
 * Checks the Javadoc of a method or constructor.
 *
 * @author Oliver Burn
 * @author Rick Giles
 * @author o_sukhodolsky
 *
 * @noinspection deprecation
 */
<span class="fc" id="L52">public class JavadocMethodCheck extends AbstractTypeAwareCheck {</span>

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_JAVADOC_MISSING = &quot;javadoc.missing&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_CLASS_INFO = &quot;javadoc.classInfo&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_UNUSED_TAG_GENERAL = &quot;javadoc.unusedTagGeneral&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_INVALID_INHERIT_DOC = &quot;javadoc.invalidInheritDoc&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_UNUSED_TAG = &quot;javadoc.unusedTag&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_EXPECTED_TAG = &quot;javadoc.expectedTag&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_RETURN_EXPECTED = &quot;javadoc.return.expected&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_DUPLICATE_TAG = &quot;javadoc.duplicateTag&quot;;

    /** Compiled regexp to match Javadoc tags that take an argument. */
<span class="fc" id="L103">    private static final Pattern MATCH_JAVADOC_ARG = CommonUtils.createPattern(</span>
            &quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(throws|exception|param)\\s+(\\S+)\\s+\\S*&quot;);

    /** Compiled regexp to match first part of multilineJavadoc tags. */
<span class="fc" id="L107">    private static final Pattern MATCH_JAVADOC_ARG_MULTILINE_START = CommonUtils.createPattern(</span>
            &quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(throws|exception|param)\\s+(\\S+)\\s*$&quot;);

    /** Compiled regexp to look for a continuation of the comment. */
<span class="fc" id="L111">    private static final Pattern MATCH_JAVADOC_MULTILINE_CONT =</span>
<span class="fc" id="L112">            CommonUtils.createPattern(&quot;(\\*/|@|[^\\s\\*])&quot;);</span>

    /** Multiline finished at end of comment. */
    private static final String END_JAVADOC = &quot;*/&quot;;
    /** Multiline finished at next Javadoc. */
    private static final String NEXT_TAG = &quot;@&quot;;

    /** Compiled regexp to match Javadoc tags with no argument. */
<span class="fc" id="L120">    private static final Pattern MATCH_JAVADOC_NOARG =</span>
<span class="fc" id="L121">            CommonUtils.createPattern(&quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(return|see)\\s+\\S&quot;);</span>
    /** Compiled regexp to match first part of multilineJavadoc tags. */
<span class="fc" id="L123">    private static final Pattern MATCH_JAVADOC_NOARG_MULTILINE_START =</span>
<span class="fc" id="L124">            CommonUtils.createPattern(&quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(return|see)\\s*$&quot;);</span>
    /** Compiled regexp to match Javadoc tags with no argument and {}. */
<span class="fc" id="L126">    private static final Pattern MATCH_JAVADOC_NOARG_CURLY =</span>
<span class="fc" id="L127">            CommonUtils.createPattern(&quot;\\{\\s*@(inheritDoc)\\s*\\}&quot;);</span>

    /** Default value of minimal amount of lines in method to allow no documentation.*/
    private static final int DEFAULT_MIN_LINE_COUNT = -1;

    /** The visibility scope where Javadoc comments are checked. */
<span class="fc" id="L133">    private Scope scope = Scope.PRIVATE;</span>

    /** The visibility scope where Javadoc comments shouldn't be checked. */
    private Scope excludeScope;

    /** Minimal amount of lines in method to allow no documentation.*/
<span class="fc" id="L139">    private int minLineCount = DEFAULT_MIN_LINE_COUNT;</span>

    /**
     * Controls whether to allow documented exceptions that are not declared if
     * they are a subclass of java.lang.RuntimeException.
     */
    // -@cs[AbbreviationAsWordInName] We can not change it as,
    // check's property is part of API (used in configurations).
    private boolean allowUndeclaredRTE;

    /**
     * Allows validating throws tags.
     */
    private boolean validateThrows;

    /**
     * Controls whether to allow documented exceptions that are subclass of one
     * of declared exception. Defaults to false (backward compatibility).
     */
    private boolean allowThrowsTagsForSubclasses;

    /**
     * Controls whether to ignore errors when a method has parameters but does
     * not have matching param tags in the javadoc. Defaults to false.
     */
    private boolean allowMissingParamTags;

    /**
     * Controls whether to ignore errors when a method declares that it throws
     * exceptions but does not have matching throws tags in the javadoc.
     * Defaults to false.
     */
    private boolean allowMissingThrowsTags;

    /**
     * Controls whether to ignore errors when a method returns non-void type
     * but does not have a return tag in the javadoc. Defaults to false.
     */
    private boolean allowMissingReturnTag;

    /**
     * Controls whether to ignore errors when there is no javadoc. Defaults to
     * false.
     */
    private boolean allowMissingJavadoc;

    /**
     * Controls whether to allow missing Javadoc on accessor methods for
     * properties (setters and getters).
     */
    private boolean allowMissingPropertyJavadoc;

    /** List of annotations that could allow missed documentation. */
<span class="fc" id="L192">    private List&lt;String&gt; allowedAnnotations = Collections.singletonList(&quot;Override&quot;);</span>

    /** Method names that match this pattern do not require javadoc blocks. */
    private Pattern ignoreMethodNamesRegex;

    /**
     * Set regex for matching method names to ignore.
     * @param pattern a pattern.
     */
    public void setIgnoreMethodNamesRegex(Pattern pattern) {
<span class="fc" id="L202">        ignoreMethodNamesRegex = pattern;</span>
<span class="fc" id="L203">    }</span>

    /**
     * Sets minimal amount of lines in method to allow no documentation.
     * @param value user's value.
     */
    public void setMinLineCount(int value) {
<span class="fc" id="L210">        minLineCount = value;</span>
<span class="fc" id="L211">    }</span>

    /**
     * Allow validating throws tag.
     * @param value user's value.
     */
    public void setValidateThrows(boolean value) {
<span class="fc" id="L218">        validateThrows = value;</span>
<span class="fc" id="L219">    }</span>

    /**
     * Sets list of annotations.
     * @param userAnnotations user's value.
     */
    public void setAllowedAnnotations(String... userAnnotations) {
<span class="fc" id="L226">        allowedAnnotations = Arrays.asList(userAnnotations);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Set the scope.
     *
     * @param scope a scope.
     */
    public void setScope(Scope scope) {
<span class="fc" id="L235">        this.scope = scope;</span>
<span class="fc" id="L236">    }</span>

    /**
     * Set the excludeScope.
     *
     * @param excludeScope a scope.
     */
    public void setExcludeScope(Scope excludeScope) {
<span class="fc" id="L244">        this.excludeScope = excludeScope;</span>
<span class="fc" id="L245">    }</span>

    /**
     * Controls whether to allow documented exceptions that are not declared if
     * they are a subclass of java.lang.RuntimeException.
     *
     * @param flag a {@code Boolean} value
     */
    // -@cs[AbbreviationAsWordInName] We can not change it as,
    // check's property is part of API (used in configurations).
    public void setAllowUndeclaredRTE(boolean flag) {
<span class="fc" id="L256">        allowUndeclaredRTE = flag;</span>
<span class="fc" id="L257">    }</span>

    /**
     * Controls whether to allow documented exception that are subclass of one
     * of declared exceptions.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowThrowsTagsForSubclasses(boolean flag) {
<span class="fc" id="L266">        allowThrowsTagsForSubclasses = flag;</span>
<span class="fc" id="L267">    }</span>

    /**
     * Controls whether to allow a method which has parameters to omit matching
     * param tags in the javadoc. Defaults to false.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingParamTags(boolean flag) {
<span class="fc" id="L276">        allowMissingParamTags = flag;</span>
<span class="fc" id="L277">    }</span>

    /**
     * Controls whether to allow a method which declares that it throws
     * exceptions to omit matching throws tags in the javadoc. Defaults to
     * false.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingThrowsTags(boolean flag) {
<span class="fc" id="L287">        allowMissingThrowsTags = flag;</span>
<span class="fc" id="L288">    }</span>

    /**
     * Controls whether to allow a method which returns non-void type to omit
     * the return tag in the javadoc. Defaults to false.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingReturnTag(boolean flag) {
<span class="fc" id="L297">        allowMissingReturnTag = flag;</span>
<span class="fc" id="L298">    }</span>

    /**
     * Controls whether to ignore errors when there is no javadoc. Defaults to
     * false.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingJavadoc(boolean flag) {
<span class="fc" id="L307">        allowMissingJavadoc = flag;</span>
<span class="fc" id="L308">    }</span>

    /**
     * Controls whether to ignore errors when there is no javadoc for a
     * property accessor (setter/getter methods). Defaults to false.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingPropertyJavadoc(final boolean flag) {
<span class="fc" id="L317">        allowMissingPropertyJavadoc = flag;</span>
<span class="fc" id="L318">    }</span>

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L322">        return getAcceptableTokens();</span>
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L327">        return new int[] {</span>
            TokenTypes.PACKAGE_DEF,
            TokenTypes.IMPORT,
            TokenTypes.CLASS_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.METHOD_DEF,
            TokenTypes.CTOR_DEF,
            TokenTypes.ANNOTATION_FIELD_DEF,
        };
    }

    @Override
    public boolean isCommentNodesRequired() {
<span class="fc" id="L341">        return true;</span>
    }

    @Override
    protected final void processAST(DetailAST ast) {
<span class="fc" id="L346">        final Scope theScope = calculateScope(ast);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (shouldCheck(ast, theScope)) {</span>
<span class="fc" id="L348">            final FileContents contents = getFileContents();</span>
<span class="fc" id="L349">            final TextBlock textBlock = contents.getJavadocBefore(ast.getLineNo());</span>

<span class="fc bfc" id="L351" title="All 2 branches covered.">            if (textBlock == null) {</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                if (!isMissingJavadocAllowed(ast)) {</span>
<span class="fc" id="L353">                    log(ast, MSG_JAVADOC_MISSING);</span>
                }
            }
            else {
<span class="fc" id="L357">                checkComment(ast, textBlock);</span>
            }
        }
<span class="fc" id="L360">    }</span>

    /**
     * Some javadoc.
     * @param methodDef Some javadoc.
     * @return Some javadoc.
     */
    private boolean hasAllowedAnnotations(DetailAST methodDef) {
<span class="fc" id="L368">        boolean result = false;</span>
<span class="fc" id="L369">        final DetailAST modifiersNode = methodDef.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L370">        DetailAST annotationNode = modifiersNode.findFirstToken(TokenTypes.ANNOTATION);</span>
<span class="fc bfc" id="L371" title="All 4 branches covered.">        while (annotationNode != null &amp;&amp; annotationNode.getType() == TokenTypes.ANNOTATION) {</span>
<span class="fc" id="L372">            DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (identNode == null) {</span>
<span class="fc" id="L374">                identNode = annotationNode.findFirstToken(TokenTypes.DOT)</span>
<span class="fc" id="L375">                    .findFirstToken(TokenTypes.IDENT);</span>
            }
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (allowedAnnotations.contains(identNode.getText())) {</span>
<span class="fc" id="L378">                result = true;</span>
<span class="fc" id="L379">                break;</span>
            }
<span class="fc" id="L381">            annotationNode = annotationNode.getNextSibling();</span>
<span class="fc" id="L382">        }</span>
<span class="fc" id="L383">        return result;</span>
    }

    /**
     * Some javadoc.
     * @param methodDef Some javadoc.
     * @return Some javadoc.
     */
    private static int getMethodsNumberOfLine(DetailAST methodDef) {
        final int numberOfLines;
<span class="fc" id="L393">        final DetailAST lcurly = methodDef.getLastChild();</span>
<span class="fc" id="L394">        final DetailAST rcurly = lcurly.getLastChild();</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (lcurly.getFirstChild() == rcurly) {</span>
<span class="fc" id="L397">            numberOfLines = 1;</span>
        }
        else {
<span class="fc" id="L400">            numberOfLines = rcurly.getLineNo() - lcurly.getLineNo() - 1;</span>
        }
<span class="fc" id="L402">        return numberOfLines;</span>
    }

    @Override
    protected final void logLoadError(Token ident) {
<span class="fc" id="L407">        logLoadErrorImpl(ident.getLineNo(), ident.getColumnNo(),</span>
            MSG_CLASS_INFO,
<span class="fc" id="L409">            JavadocTagInfo.THROWS.getText(), ident.getText());</span>
<span class="fc" id="L410">    }</span>

    /**
     * Checks if a missing Javadoc is allowed by the check's configuration.
     * @param ast the tree node for the method or constructor.
     * @return True if this method or constructor doesn't need Javadoc.
     */
    private boolean isMissingJavadocAllowed(final DetailAST ast) {
<span class="fc bfc" id="L418" title="All 4 branches covered.">        return allowMissingJavadoc</span>
            || allowMissingPropertyJavadoc
<span class="fc bfc" id="L420" title="All 4 branches covered.">                &amp;&amp; (CheckUtils.isSetterMethod(ast) || CheckUtils.isGetterMethod(ast))</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">            || matchesSkipRegex(ast)</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">            || isContentsAllowMissingJavadoc(ast);</span>
    }

    /**
     * Checks if the Javadoc can be missing if the method or constructor is
     * below the minimum line count or has a special annotation.
     *
     * @param ast the tree node for the method or constructor.
     * @return True if this method or constructor doesn't need Javadoc.
     */
    private boolean isContentsAllowMissingJavadoc(DetailAST ast) {
<span class="fc bfc" id="L433" title="All 4 branches covered.">        return (ast.getType() == TokenTypes.METHOD_DEF || ast.getType() == TokenTypes.CTOR_DEF)</span>
<span class="fc bfc" id="L434" title="All 4 branches covered.">                &amp;&amp; (getMethodsNumberOfLine(ast) &lt;= minLineCount || hasAllowedAnnotations(ast));</span>
    }

    /**
     * Checks if the given method name matches the regex. In that case
     * we skip enforcement of javadoc for this method
     * @param methodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
     * @return true if given method name matches the regex.
     */
    private boolean matchesSkipRegex(DetailAST methodDef) {
<span class="fc" id="L444">        boolean result = false;</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (ignoreMethodNamesRegex != null) {</span>
<span class="fc" id="L446">            final DetailAST ident = methodDef.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc" id="L447">            final String methodName = ident.getText();</span>

<span class="fc" id="L449">            final Matcher matcher = ignoreMethodNamesRegex.matcher(methodName);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (matcher.matches()) {</span>
<span class="fc" id="L451">                result = true;</span>
            }
        }
<span class="fc" id="L454">        return result;</span>
    }

    /**
     * Whether we should check this node.
     *
     * @param ast a given node.
     * @param nodeScope the scope of the node.
     * @return whether we should check a given node.
     */
    private boolean shouldCheck(final DetailAST ast, final Scope nodeScope) {
<span class="fc" id="L465">        final Scope surroundingScope = ScopeUtils.getSurroundingScope(ast);</span>

<span class="fc bfc" id="L467" title="All 6 branches covered.">        return (excludeScope == null</span>
                || nodeScope != excludeScope
                &amp;&amp; surroundingScope != excludeScope)
<span class="fc bfc" id="L470" title="All 2 branches covered.">            &amp;&amp; nodeScope.isIn(scope)</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            &amp;&amp; surroundingScope.isIn(scope);</span>
    }

    /**
     * Checks the Javadoc for a method.
     *
     * @param ast the token for the method
     * @param comment the Javadoc comment
     */
    private void checkComment(DetailAST ast, TextBlock comment) {
<span class="fc" id="L481">        final List&lt;JavadocTag&gt; tags = getMethodTags(comment);</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (!hasShortCircuitTag(ast, tags)) {</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (ast.getType() == TokenTypes.ANNOTATION_FIELD_DEF) {</span>
<span class="fc" id="L485">                checkReturnTag(tags, ast.getLineNo(), true);</span>
            }
            else {
<span class="fc" id="L488">                final Iterator&lt;JavadocTag&gt; it = tags.iterator();</span>
                // Check for inheritDoc
<span class="fc" id="L490">                boolean hasInheritDocTag = false;</span>
<span class="fc bfc" id="L491" title="All 4 branches covered.">                while (!hasInheritDocTag &amp;&amp; it.hasNext()) {</span>
<span class="fc" id="L492">                    hasInheritDocTag = it.next().isInheritDocTag();</span>
                }
<span class="fc bfc" id="L494" title="All 4 branches covered.">                final boolean reportExpectedTags = !hasInheritDocTag &amp;&amp; !hasAllowedAnnotations(ast);</span>

<span class="fc" id="L496">                checkParamTags(tags, ast, reportExpectedTags);</span>
<span class="fc" id="L497">                checkThrowsTags(tags, getThrows(ast), reportExpectedTags);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">                if (CheckUtils.isNonVoidMethod(ast)) {</span>
<span class="fc" id="L499">                    checkReturnTag(tags, ast.getLineNo(), reportExpectedTags);</span>
                }
            }

            // Dump out all unused tags
<span class="fc bfc" id="L504" title="All 2 branches covered.">            tags.stream().filter(javadocTag -&gt; !javadocTag.isSeeOrInheritDocTag())</span>
<span class="fc" id="L505">                .forEach(javadocTag -&gt; log(javadocTag.getLineNo(), MSG_UNUSED_TAG_GENERAL));</span>
        }
<span class="fc" id="L507">    }</span>

    /**
     * Validates whether the Javadoc has a short circuit tag. Currently this is
     * the inheritTag. Any errors are logged.
     *
     * @param ast the construct being checked
     * @param tags the list of Javadoc tags associated with the construct
     * @return true if the construct has a short circuit tag.
     */
    private boolean hasShortCircuitTag(final DetailAST ast, final List&lt;JavadocTag&gt; tags) {
<span class="fc" id="L518">        boolean result = true;</span>
        // Check if it contains {@inheritDoc} tag
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (tags.size() == 1</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">                &amp;&amp; tags.get(0).isInheritDocTag()) {</span>
            // Invalid if private, a constructor, or a static method
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {</span>
<span class="fc" id="L524">                log(ast, MSG_INVALID_INHERIT_DOC);</span>
            }
        }
        else {
<span class="fc" id="L528">            result = false;</span>
        }
<span class="fc" id="L530">        return result;</span>
    }

    /**
     * Returns the scope for the method/constructor at the specified AST. If
     * the method is in an interface or annotation block, the scope is assumed
     * to be public.
     *
     * @param ast the token of the method/constructor
     * @return the scope of the method/constructor
     */
    private static Scope calculateScope(final DetailAST ast) {
        final Scope scope;

<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {</span>
<span class="fc" id="L545">            scope = Scope.PUBLIC;</span>
        }
        else {
<span class="fc" id="L548">            final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L549">            scope = ScopeUtils.getScopeFromMods(mods);</span>
        }
<span class="fc" id="L551">        return scope;</span>
    }

    /**
     * Returns the tags in a javadoc comment. Only finds throws, exception,
     * param, return and see tags.
     *
     * @param comment the Javadoc comment
     * @return the tags found
     */
    private static List&lt;JavadocTag&gt; getMethodTags(TextBlock comment) {
<span class="fc" id="L562">        final String[] lines = comment.getText();</span>
<span class="fc" id="L563">        final List&lt;JavadocTag&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L564">        int currentLine = comment.getStartLineNo() - 1;</span>
<span class="fc" id="L565">        final int startColumnNumber = comment.getStartColNo();</span>

<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (int i = 0; i &lt; lines.length; i++) {</span>
<span class="fc" id="L568">            currentLine++;</span>
<span class="fc" id="L569">            final Matcher javadocArgMatcher =</span>
<span class="fc" id="L570">                MATCH_JAVADOC_ARG.matcher(lines[i]);</span>
<span class="fc" id="L571">            final Matcher javadocNoargMatcher =</span>
<span class="fc" id="L572">                MATCH_JAVADOC_NOARG.matcher(lines[i]);</span>
<span class="fc" id="L573">            final Matcher noargCurlyMatcher =</span>
<span class="fc" id="L574">                MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);</span>
<span class="fc" id="L575">            final Matcher argMultilineStart =</span>
<span class="fc" id="L576">                MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);</span>
<span class="fc" id="L577">            final Matcher noargMultilineStart =</span>
<span class="fc" id="L578">                MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);</span>

<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (javadocArgMatcher.find()) {</span>
<span class="fc" id="L581">                final int col = calculateTagColumn(javadocArgMatcher, i, startColumnNumber);</span>
<span class="fc" id="L582">                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),</span>
<span class="fc" id="L583">                        javadocArgMatcher.group(2)));</span>
<span class="fc" id="L584">            }</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            else if (javadocNoargMatcher.find()) {</span>
<span class="fc" id="L586">                final int col = calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);</span>
<span class="fc" id="L587">                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));</span>
<span class="fc" id="L588">            }</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">            else if (noargCurlyMatcher.find()) {</span>
<span class="fc" id="L590">                final int col = calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);</span>
<span class="fc" id="L591">                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));</span>
<span class="fc" id="L592">            }</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            else if (argMultilineStart.find()) {</span>
<span class="fc" id="L594">                final int col = calculateTagColumn(argMultilineStart, i, startColumnNumber);</span>
<span class="fc" id="L595">                tags.addAll(getMultilineArgTags(argMultilineStart, col, lines, i, currentLine));</span>
<span class="fc" id="L596">            }</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            else if (noargMultilineStart.find()) {</span>
<span class="fc" id="L598">                tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));</span>
            }
        }
<span class="fc" id="L601">        return tags;</span>
    }

    /**
     * Calculates column number using Javadoc tag matcher.
     * @param javadocTagMatcher found javadoc tag matcher
     * @param lineNumber line number of Javadoc tag in comment
     * @param startColumnNumber column number of Javadoc comment beginning
     * @return column number
     */
    private static int calculateTagColumn(Matcher javadocTagMatcher,
            int lineNumber, int startColumnNumber) {
<span class="fc" id="L613">        int col = javadocTagMatcher.start(1) - 1;</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (lineNumber == 0) {</span>
<span class="fc" id="L615">            col += startColumnNumber;</span>
        }
<span class="fc" id="L617">        return col;</span>
    }

    /**
     * Gets multiline Javadoc tags with arguments.
     * @param argMultilineStart javadoc tag Matcher
     * @param column column number of Javadoc tag
     * @param lines comment text lines
     * @param lineIndex line number that contains the javadoc tag
     * @param tagLine javadoc tag line number in file
     * @return javadoc tags with arguments
     */
    private static List&lt;JavadocTag&gt; getMultilineArgTags(final Matcher argMultilineStart,
            final int column, final String[] lines, final int lineIndex, final int tagLine) {
<span class="fc" id="L631">        final List&lt;JavadocTag&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L632">        final String param1 = argMultilineStart.group(1);</span>
<span class="fc" id="L633">        final String param2 = argMultilineStart.group(2);</span>
<span class="fc" id="L634">        int remIndex = lineIndex + 1;</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        while (remIndex &lt; lines.length) {</span>
<span class="fc" id="L636">            final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (multilineCont.find()) {</span>
<span class="fc" id="L638">                remIndex = lines.length;</span>
<span class="fc" id="L639">                final String lFin = multilineCont.group(1);</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if (!lFin.equals(NEXT_TAG)</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                    &amp;&amp; !lFin.equals(END_JAVADOC)) {</span>
<span class="fc" id="L642">                    tags.add(new JavadocTag(tagLine, column, param1, param2));</span>
                }
            }
<span class="fc" id="L645">            remIndex++;</span>
<span class="fc" id="L646">        }</span>
<span class="fc" id="L647">        return tags;</span>
    }

    /**
     * Gets multiline Javadoc tags with no arguments.
     * @param noargMultilineStart javadoc tag Matcher
     * @param lines comment text lines
     * @param lineIndex line number that contains the javadoc tag
     * @param tagLine javadoc tag line number in file
     * @return javadoc tags with no arguments
     */
    private static List&lt;JavadocTag&gt; getMultilineNoArgTags(final Matcher noargMultilineStart,
            final String[] lines, final int lineIndex, final int tagLine) {
<span class="fc" id="L660">        final String param1 = noargMultilineStart.group(1);</span>
<span class="fc" id="L661">        final int col = noargMultilineStart.start(1) - 1;</span>
<span class="fc" id="L662">        final List&lt;JavadocTag&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L663">        int remIndex = lineIndex + 1;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        while (remIndex &lt; lines.length) {</span>
<span class="fc" id="L665">            final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT</span>
<span class="fc" id="L666">                    .matcher(lines[remIndex]);</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">            if (multilineCont.find()) {</span>
<span class="fc" id="L668">                remIndex = lines.length;</span>
<span class="fc" id="L669">                final String lFin = multilineCont.group(1);</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                if (!lFin.equals(NEXT_TAG)</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">                    &amp;&amp; !lFin.equals(END_JAVADOC)) {</span>
<span class="fc" id="L672">                    tags.add(new JavadocTag(tagLine, col, param1));</span>
                }
            }
<span class="fc" id="L675">            remIndex++;</span>
<span class="fc" id="L676">        }</span>

<span class="fc" id="L678">        return tags;</span>
    }

    /**
     * Computes the parameter nodes for a method.
     *
     * @param ast the method node.
     * @return the list of parameter nodes for ast.
     */
    private static List&lt;DetailAST&gt; getParameters(DetailAST ast) {
<span class="fc" id="L688">        final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);</span>
<span class="fc" id="L689">        final List&lt;DetailAST&gt; returnValue = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L691">        DetailAST child = params.getFirstChild();</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">        while (child != null) {</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">            if (child.getType() == TokenTypes.PARAMETER_DEF) {</span>
<span class="fc" id="L694">                final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                if (ident != null) {</span>
<span class="fc" id="L696">                    returnValue.add(ident);</span>
                }
            }
<span class="fc" id="L699">            child = child.getNextSibling();</span>
        }
<span class="fc" id="L701">        return returnValue;</span>
    }

    /**
     * Computes the exception nodes for a method.
     *
     * @param ast the method node.
     * @return the list of exception nodes for ast.
     */
    private List&lt;ExceptionInfo&gt; getThrows(DetailAST ast) {
<span class="fc" id="L711">        final List&lt;ExceptionInfo&gt; returnValue = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L712">        final DetailAST throwsAST = ast</span>
<span class="fc" id="L713">                .findFirstToken(TokenTypes.LITERAL_THROWS);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (throwsAST != null) {</span>
<span class="fc" id="L715">            DetailAST child = throwsAST.getFirstChild();</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            while (child != null) {</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                if (child.getType() == TokenTypes.IDENT</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">                        || child.getType() == TokenTypes.DOT) {</span>
<span class="fc" id="L719">                    final FullIdent ident = FullIdent.createFullIdent(child);</span>
<span class="fc" id="L720">                    final ExceptionInfo exceptionInfo = new ExceptionInfo(</span>
<span class="fc" id="L721">                            createClassInfo(new Token(ident), getCurrentClassName()));</span>
<span class="fc" id="L722">                    returnValue.add(exceptionInfo);</span>
                }
<span class="fc" id="L724">                child = child.getNextSibling();</span>
            }
        }
<span class="fc" id="L727">        return returnValue;</span>
    }

    /**
     * Checks a set of tags for matching parameters.
     *
     * @param tags the tags to check
     * @param parent the node which takes the parameters
     * @param reportExpectedTags whether we should report if do not find
     *            expected tag
     */
    private void checkParamTags(final List&lt;JavadocTag&gt; tags,
            final DetailAST parent, boolean reportExpectedTags) {
<span class="fc" id="L740">        final List&lt;DetailAST&gt; params = getParameters(parent);</span>
<span class="fc" id="L741">        final List&lt;DetailAST&gt; typeParams = CheckUtils</span>
<span class="fc" id="L742">                .getTypeParameters(parent);</span>

        // Loop over the tags, checking to see they exist in the params.
<span class="fc" id="L745">        final ListIterator&lt;JavadocTag&gt; tagIt = tags.listIterator();</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">        while (tagIt.hasNext()) {</span>
<span class="fc" id="L747">            final JavadocTag tag = tagIt.next();</span>

<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (!tag.isParamTag()) {</span>
<span class="fc" id="L750">                continue;</span>
            }

<span class="fc" id="L753">            tagIt.remove();</span>

<span class="fc" id="L755">            final String arg1 = tag.getFirstArg();</span>
<span class="fc" id="L756">            boolean found = removeMatchingParam(params, arg1);</span>

<span class="fc bfc" id="L758" title="All 4 branches covered.">            if (CommonUtils.startsWithChar(arg1, '&lt;') &amp;&amp; CommonUtils.endsWithChar(arg1, '&gt;')) {</span>
<span class="fc" id="L759">                found = searchMatchingTypeParameter(typeParams,</span>
<span class="fc" id="L760">                        arg1.substring(1, arg1.length() - 1));</span>
            }

            // Handle extra JavadocTag
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L765">                log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,</span>
                        &quot;@param&quot;, arg1);
            }
<span class="fc" id="L768">        }</span>

        // Now dump out all type parameters/parameters without tags :- unless
        // the user has chosen to suppress these problems
<span class="fc bfc" id="L772" title="All 4 branches covered.">        if (!allowMissingParamTags &amp;&amp; reportExpectedTags) {</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">            for (DetailAST param : params) {</span>
<span class="fc" id="L774">                log(param, MSG_EXPECTED_TAG,</span>
<span class="fc" id="L775">                    JavadocTagInfo.PARAM.getText(), param.getText());</span>
<span class="fc" id="L776">            }</span>

<span class="fc bfc" id="L778" title="All 2 branches covered.">            for (DetailAST typeParam : typeParams) {</span>
<span class="fc" id="L779">                log(typeParam, MSG_EXPECTED_TAG,</span>
<span class="fc" id="L780">                    JavadocTagInfo.PARAM.getText(),</span>
<span class="fc" id="L781">                    &quot;&lt;&quot; + typeParam.findFirstToken(TokenTypes.IDENT).getText()</span>
                    + &quot;&gt;&quot;);
<span class="fc" id="L783">            }</span>
        }
<span class="fc" id="L785">    }</span>

    /**
     * Returns true if required type found in type parameters.
     * @param typeParams
     *            list of type parameters
     * @param requiredTypeName
     *            name of required type
     * @return true if required type found in type parameters.
     */
    private static boolean searchMatchingTypeParameter(List&lt;DetailAST&gt; typeParams,
            String requiredTypeName) {
        // Loop looking for matching type param
<span class="fc" id="L798">        final Iterator&lt;DetailAST&gt; typeParamsIt = typeParams.iterator();</span>
<span class="fc" id="L799">        boolean found = false;</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">        while (typeParamsIt.hasNext()) {</span>
<span class="fc" id="L801">            final DetailAST typeParam = typeParamsIt.next();</span>
<span class="fc" id="L802">            if (typeParam.findFirstToken(TokenTypes.IDENT).getText()</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">                    .equals(requiredTypeName)) {</span>
<span class="fc" id="L804">                found = true;</span>
<span class="fc" id="L805">                typeParamsIt.remove();</span>
<span class="fc" id="L806">                break;</span>
            }
<span class="fc" id="L808">        }</span>
<span class="fc" id="L809">        return found;</span>
    }

    /**
     * Remove parameter from params collection by name.
     * @param params collection of DetailAST parameters
     * @param paramName name of parameter
     * @return true if parameter found and removed
     */
    private static boolean removeMatchingParam(List&lt;DetailAST&gt; params, String paramName) {
<span class="fc" id="L819">        boolean found = false;</span>
<span class="fc" id="L820">        final Iterator&lt;DetailAST&gt; paramIt = params.iterator();</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">        while (paramIt.hasNext()) {</span>
<span class="fc" id="L822">            final DetailAST param = paramIt.next();</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">            if (param.getText().equals(paramName)) {</span>
<span class="fc" id="L824">                found = true;</span>
<span class="fc" id="L825">                paramIt.remove();</span>
<span class="fc" id="L826">                break;</span>
            }
<span class="fc" id="L828">        }</span>
<span class="fc" id="L829">        return found;</span>
    }

    /**
     * Checks for only one return tag. All return tags will be removed from the
     * supplied list.
     *
     * @param tags the tags to check
     * @param lineNo the line number of the expected tag
     * @param reportExpectedTags whether we should report if do not find
     *            expected tag
     */
    private void checkReturnTag(List&lt;JavadocTag&gt; tags, int lineNo,
        boolean reportExpectedTags) {
        // Loop over tags finding return tags. After the first one, report an
        // error.
<span class="fc" id="L845">        boolean found = false;</span>
<span class="fc" id="L846">        final ListIterator&lt;JavadocTag&gt; it = tags.listIterator();</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L848">            final JavadocTag javadocTag = it.next();</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">            if (javadocTag.isReturnTag()) {</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">                if (found) {</span>
<span class="fc" id="L851">                    log(javadocTag.getLineNo(), javadocTag.getColumnNo(),</span>
                            MSG_DUPLICATE_TAG,
<span class="fc" id="L853">                            JavadocTagInfo.RETURN.getText());</span>
                }
<span class="fc" id="L855">                found = true;</span>
<span class="fc" id="L856">                it.remove();</span>
            }
<span class="fc" id="L858">        }</span>

        // Handle there being no @return tags :- unless
        // the user has chosen to suppress these problems
<span class="fc bfc" id="L862" title="All 6 branches covered.">        if (!found &amp;&amp; !allowMissingReturnTag &amp;&amp; reportExpectedTags) {</span>
<span class="fc" id="L863">            log(lineNo, MSG_RETURN_EXPECTED);</span>
        }
<span class="fc" id="L865">    }</span>

    /**
     * Checks a set of tags for matching throws.
     *
     * @param tags the tags to check
     * @param throwsList the throws to check
     * @param reportExpectedTags whether we should report if do not find
     *            expected tag
     */
    private void checkThrowsTags(List&lt;JavadocTag&gt; tags,
            List&lt;ExceptionInfo&gt; throwsList, boolean reportExpectedTags) {
        // Loop over the tags, checking to see they exist in the throws.
        // The foundThrows used for performance only
<span class="fc" id="L879">        final Set&lt;String&gt; foundThrows = new HashSet&lt;&gt;();</span>
<span class="fc" id="L880">        final ListIterator&lt;JavadocTag&gt; tagIt = tags.listIterator();</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">        while (tagIt.hasNext()) {</span>
<span class="fc" id="L882">            final JavadocTag tag = tagIt.next();</span>

<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (!tag.isThrowsTag()) {</span>
<span class="fc" id="L885">                continue;</span>
            }
<span class="fc" id="L887">            tagIt.remove();</span>

            // Loop looking for matching throw
<span class="fc" id="L890">            final String documentedEx = tag.getFirstArg();</span>
<span class="fc" id="L891">            final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag</span>
<span class="fc" id="L892">                    .getColumnNo());</span>
<span class="fc" id="L893">            final AbstractClassInfo documentedClassInfo = createClassInfo(token,</span>
<span class="fc" id="L894">                    getCurrentClassName());</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">            final boolean found = foundThrows.contains(documentedEx)</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">                    || isInThrows(throwsList, documentedClassInfo, foundThrows);</span>

            // Handle extra JavadocTag.
<span class="fc bfc" id="L899" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L900">                boolean reqd = true;</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">                if (allowUndeclaredRTE) {</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">                    reqd = !isUnchecked(documentedClassInfo.getClazz());</span>
                }

<span class="fc bfc" id="L905" title="All 4 branches covered.">                if (reqd &amp;&amp; validateThrows) {</span>
<span class="fc" id="L906">                    log(tag.getLineNo(), tag.getColumnNo(),</span>
                        MSG_UNUSED_TAG,
<span class="fc" id="L908">                        JavadocTagInfo.THROWS.getText(), tag.getFirstArg());</span>
                }
            }
<span class="fc" id="L911">        }</span>
        // Now dump out all throws without tags :- unless
        // the user has chosen to suppress these problems
<span class="fc bfc" id="L914" title="All 4 branches covered.">        if (!allowMissingThrowsTags &amp;&amp; reportExpectedTags) {</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">            throwsList.stream().filter(exceptionInfo -&gt; !exceptionInfo.isFound())</span>
<span class="fc" id="L916">                .forEach(exceptionInfo -&gt; {</span>
<span class="fc" id="L917">                    final Token token = exceptionInfo.getName();</span>
<span class="fc" id="L918">                    log(token.getLineNo(), token.getColumnNo(),</span>
                        MSG_EXPECTED_TAG,
<span class="fc" id="L920">                        JavadocTagInfo.THROWS.getText(), token.getText());</span>
<span class="fc" id="L921">                });</span>
        }
<span class="fc" id="L923">    }</span>

    /**
     * Verifies that documented exception is in throws.
     *
     * @param throwsList list of throws
     * @param documentedClassInfo documented exception class info
     * @param foundThrows previously found throws
     * @return true if documented exception is in throws.
     */
    private boolean isInThrows(List&lt;ExceptionInfo&gt; throwsList,
            AbstractClassInfo documentedClassInfo, Set&lt;String&gt; foundThrows) {
<span class="fc" id="L935">        boolean found = false;</span>
<span class="fc" id="L936">        ExceptionInfo foundException = null;</span>

        // First look for matches on the exception name
<span class="fc bfc" id="L939" title="All 2 branches covered.">        for (ExceptionInfo exceptionInfo : throwsList) {</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">            if (exceptionInfo.getName().getText().equals(</span>
<span class="fc" id="L941">                    documentedClassInfo.getName().getText())) {</span>
<span class="fc" id="L942">                found = true;</span>
<span class="fc" id="L943">                foundException = exceptionInfo;</span>
<span class="fc" id="L944">                break;</span>
            }
<span class="fc" id="L946">        }</span>

        // Now match on the exception type
<span class="fc" id="L949">        final ListIterator&lt;ExceptionInfo&gt; exceptionInfoIt = throwsList.listIterator();</span>
<span class="fc bfc" id="L950" title="All 4 branches covered.">        while (!found &amp;&amp; exceptionInfoIt.hasNext()) {</span>
<span class="fc" id="L951">            final ExceptionInfo exceptionInfo = exceptionInfoIt.next();</span>

<span class="fc bfc" id="L953" title="All 2 branches covered.">            if (documentedClassInfo.getClazz() == exceptionInfo.getClazz()) {</span>
<span class="fc" id="L954">                found = true;</span>
<span class="fc" id="L955">                foundException = exceptionInfo;</span>
            }
<span class="fc bfc" id="L957" title="All 2 branches covered.">            else if (allowThrowsTagsForSubclasses) {</span>
<span class="fc" id="L958">                found = isSubclass(documentedClassInfo.getClazz(), exceptionInfo.getClazz());</span>
            }
<span class="fc" id="L960">        }</span>

<span class="fc bfc" id="L962" title="All 2 branches covered.">        if (foundException != null) {</span>
<span class="fc" id="L963">            foundException.setFound();</span>
<span class="fc" id="L964">            foundThrows.add(documentedClassInfo.getName().getText());</span>
        }

<span class="fc" id="L967">        return found;</span>
    }

    /** Stores useful information about declared exception. */
    private static class ExceptionInfo {

        /** Class information associated with this exception. */
        private final AbstractClassInfo classInfo;
        /** Does the exception have throws tag associated with. */
        private boolean found;

        /**
         * Creates new instance for {@code FullIdent}.
         *
         * @param classInfo class info
         */
<span class="fc" id="L983">        ExceptionInfo(AbstractClassInfo classInfo) {</span>
<span class="fc" id="L984">            this.classInfo = classInfo;</span>
<span class="fc" id="L985">        }</span>

        /** Mark that the exception has associated throws tag. */
        private void setFound() {
<span class="fc" id="L989">            found = true;</span>
<span class="fc" id="L990">        }</span>

        /**
         * Checks that the exception has throws tag associated with it.
         * @return whether the exception has throws tag associated with
         */
        private boolean isFound() {
<span class="fc" id="L997">            return found;</span>
        }

        /**
         * Gets exception name.
         * @return exception's name
         */
        private Token getName() {
<span class="fc" id="L1005">            return classInfo.getName();</span>
        }

        /**
         * Gets exception class.
         * @return class for this exception
         */
        private Class&lt;?&gt; getClazz() {
<span class="fc" id="L1013">            return classInfo.getClazz();</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>