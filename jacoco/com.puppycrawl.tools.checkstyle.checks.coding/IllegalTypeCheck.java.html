<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IllegalTypeCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.coding</a> &gt; <span class="el_source">IllegalTypeCheck.java</span></div><h1>IllegalTypeCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2018 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.coding;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.TokenUtil;

/**
 * Checks that particular class are never used as types in variable
 * declarations, return values or parameters.
 *
 * &lt;p&gt;Rationale:
 * Helps reduce coupling on concrete classes.
 *
 * &lt;p&gt;Check has following properties:
 *
 * &lt;p&gt;&lt;b&gt;format&lt;/b&gt; - Pattern for illegal class names.
 *
 * &lt;p&gt;&lt;b&gt;legalAbstractClassNames&lt;/b&gt; - Abstract classes that may be used as types.
 *
 * &lt;p&gt;&lt;b&gt;illegalClassNames&lt;/b&gt; - Classes that should not be used as types in variable
   declarations, return values or parameters.
 * It is possible to set illegal class names via short or
 * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7&quot;&gt;
 *  canonical&lt;/a&gt; name.
 *  Specifying illegal type invokes analyzing imports and Check puts violations at
 *   corresponding declarations
 *  (of variables, methods or parameters). This helps to avoid ambiguous cases, e.g.:
 *
 * &lt;p&gt;{@code java.awt.List} was set as illegal class name, then, code like:
 *
 * &lt;p&gt;{@code
 * import java.util.List;&lt;br&gt;
 * ...&lt;br&gt;
 * List list; //No violation here
 * }
 *
 * &lt;p&gt;will be ok.
 *
 * &lt;p&gt;&lt;b&gt;validateAbstractClassNames&lt;/b&gt; - controls whether to validate abstract class names.
 * Default value is &lt;b&gt;false&lt;/b&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;ignoredMethodNames&lt;/b&gt; - Methods that should not be checked.
 *
 * &lt;p&gt;&lt;b&gt;memberModifiers&lt;/b&gt; - To check only methods and fields with only specified modifiers.
 *
 * &lt;p&gt;In most cases it's justified to put following classes to &lt;b&gt;illegalClassNames&lt;/b&gt;:
 * &lt;ul&gt;
 * &lt;li&gt;GregorianCalendar&lt;/li&gt;
 * &lt;li&gt;Hashtable&lt;/li&gt;
 * &lt;li&gt;ArrayList&lt;/li&gt;
 * &lt;li&gt;LinkedList&lt;/li&gt;
 * &lt;li&gt;Vector&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;as methods that are differ from interface methods are rear used, so in most cases user will
 *  benefit from checking for them.
 * &lt;/p&gt;
 *
 */
@FileStatefulCheck
public final class IllegalTypeCheck extends AbstractCheck {

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_KEY = &quot;illegal.type&quot;;

    /** Types illegal by default. */
<span class="fc" id="L100">    private static final String[] DEFAULT_ILLEGAL_TYPES = {</span>
        &quot;HashSet&quot;,
        &quot;HashMap&quot;,
        &quot;LinkedHashMap&quot;,
        &quot;LinkedHashSet&quot;,
        &quot;TreeSet&quot;,
        &quot;TreeMap&quot;,
        &quot;java.util.HashSet&quot;,
        &quot;java.util.HashMap&quot;,
        &quot;java.util.LinkedHashMap&quot;,
        &quot;java.util.LinkedHashSet&quot;,
        &quot;java.util.TreeSet&quot;,
        &quot;java.util.TreeMap&quot;,
    };

    /** Default ignored method names. */
<span class="fc" id="L116">    private static final String[] DEFAULT_IGNORED_METHOD_NAMES = {</span>
        &quot;getInitialContext&quot;,
        &quot;getEnvironment&quot;,
    };

    /** Illegal classes. */
<span class="fc" id="L122">    private final Set&lt;String&gt; illegalClassNames = new HashSet&lt;&gt;();</span>
    /** Illegal short classes. */
<span class="fc" id="L124">    private final Set&lt;String&gt; illegalShortClassNames = new HashSet&lt;&gt;();</span>
    /** Legal abstract classes. */
<span class="fc" id="L126">    private final Set&lt;String&gt; legalAbstractClassNames = new HashSet&lt;&gt;();</span>
    /** Methods which should be ignored. */
<span class="fc" id="L128">    private final Set&lt;String&gt; ignoredMethodNames = new HashSet&lt;&gt;();</span>
    /** Check methods and fields with only corresponding modifiers. */
    private List&lt;Integer&gt; memberModifiers;

    /** The regexp to match against. */
<span class="fc" id="L133">    private Pattern format = Pattern.compile(&quot;^(.*[.])?Abstract.*$&quot;);</span>

    /**
     * Controls whether to validate abstract class names.
     */
    private boolean validateAbstractClassNames;

    /** Creates new instance of the check. */
<span class="fc" id="L141">    public IllegalTypeCheck() {</span>
<span class="fc" id="L142">        setIllegalClassNames(DEFAULT_ILLEGAL_TYPES);</span>
<span class="fc" id="L143">        setIgnoredMethodNames(DEFAULT_IGNORED_METHOD_NAMES);</span>
<span class="fc" id="L144">    }</span>

    /**
     * Set the format for the specified regular expression.
     * @param pattern a pattern.
     */
    public void setFormat(Pattern pattern) {
<span class="fc" id="L151">        format = pattern;</span>
<span class="fc" id="L152">    }</span>

    /**
     * Sets whether to validate abstract class names.
     * @param validateAbstractClassNames whether abstract class names must be ignored.
     */
    public void setValidateAbstractClassNames(boolean validateAbstractClassNames) {
<span class="fc" id="L159">        this.validateAbstractClassNames = validateAbstractClassNames;</span>
<span class="fc" id="L160">    }</span>

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L164">        return getAcceptableTokens();</span>
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L169">        return new int[] {</span>
            TokenTypes.VARIABLE_DEF,
            TokenTypes.PARAMETER_DEF,
            TokenTypes.METHOD_DEF,
            TokenTypes.IMPORT,
        };
    }

    @Override
    public void beginTree(DetailAST rootAST) {
<span class="fc" id="L179">        illegalShortClassNames.clear();</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (String s : illegalClassNames) {</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (s.indexOf('.') == -1) {</span>
<span class="fc" id="L183">                illegalShortClassNames.add(s);</span>
            }
<span class="fc" id="L185">        }</span>
<span class="fc" id="L186">    }</span>

    @Override
    public int[] getRequiredTokens() {
<span class="fc" id="L190">        return new int[] {TokenTypes.IMPORT};</span>
    }

    @Override
    public void visitToken(DetailAST ast) {
<span class="fc bfc" id="L195" title="All 5 branches covered.">        switch (ast.getType()) {</span>
            case TokenTypes.METHOD_DEF:
<span class="fc bfc" id="L197" title="All 2 branches covered.">                if (isVerifiable(ast)) {</span>
<span class="fc" id="L198">                    visitMethodDef(ast);</span>
                }
                break;
            case TokenTypes.VARIABLE_DEF:
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (isVerifiable(ast)) {</span>
<span class="fc" id="L203">                    visitVariableDef(ast);</span>
                }
                break;
            case TokenTypes.PARAMETER_DEF:
<span class="fc" id="L207">                visitParameterDef(ast);</span>
<span class="fc" id="L208">                break;</span>
            case TokenTypes.IMPORT:
<span class="fc" id="L210">                visitImport(ast);</span>
<span class="fc" id="L211">                break;</span>
            default:
<span class="fc" id="L213">                throw new IllegalStateException(ast.toString());</span>
        }
<span class="fc" id="L215">    }</span>

    /**
     * Checks if current method's return type or variable's type is verifiable
     * according to &lt;b&gt;memberModifiers&lt;/b&gt; option.
     * @param methodOrVariableDef METHOD_DEF or VARIABLE_DEF ast node.
     * @return true if member is verifiable according to &lt;b&gt;memberModifiers&lt;/b&gt; option.
     */
    private boolean isVerifiable(DetailAST methodOrVariableDef) {
<span class="fc" id="L224">        boolean result = true;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (memberModifiers != null) {</span>
<span class="fc" id="L226">            final DetailAST modifiersAst = methodOrVariableDef</span>
<span class="fc" id="L227">                    .findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L228">            result = isContainVerifiableType(modifiersAst);</span>
        }
<span class="fc" id="L230">        return result;</span>
    }

    /**
     * Checks is modifiers contain verifiable type.
     *
     * @param modifiers
     *            parent node for all modifiers
     * @return true if method or variable can be verified
     */
    private boolean isContainVerifiableType(DetailAST modifiers) {
<span class="fc" id="L241">        boolean result = false;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (modifiers.getFirstChild() != null) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (DetailAST modifier = modifiers.getFirstChild(); modifier != null;</span>
<span class="fc" id="L244">                     modifier = modifier.getNextSibling()) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                if (memberModifiers.contains(modifier.getType())) {</span>
<span class="fc" id="L246">                    result = true;</span>
<span class="fc" id="L247">                    break;</span>
                }
            }
        }
<span class="fc" id="L251">        return result;</span>
    }

    /**
     * Checks return type of a given method.
     * @param methodDef method for check.
     */
    private void visitMethodDef(DetailAST methodDef) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (isCheckedMethod(methodDef)) {</span>
<span class="fc" id="L260">            checkClassName(methodDef);</span>
        }
<span class="fc" id="L262">    }</span>

    /**
     * Checks type of parameters.
     * @param parameterDef parameter list for check.
     */
    private void visitParameterDef(DetailAST parameterDef) {
<span class="fc" id="L269">        final DetailAST grandParentAST = parameterDef.getParent().getParent();</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (grandParentAST.getType() == TokenTypes.METHOD_DEF</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            &amp;&amp; isCheckedMethod(grandParentAST)) {</span>
<span class="fc" id="L273">            checkClassName(parameterDef);</span>
        }
<span class="fc" id="L275">    }</span>

    /**
     * Checks type of given variable.
     * @param variableDef variable to check.
     */
    private void visitVariableDef(DetailAST variableDef) {
<span class="fc" id="L282">        checkClassName(variableDef);</span>
<span class="fc" id="L283">    }</span>

    /**
     * Checks imported type (as static and star imports are not supported by Check,
     *  only type is in the consideration).&lt;br&gt;
     * If this type is illegal due to Check's options - puts violation on it.
     * @param importAst {@link TokenTypes#IMPORT Import}
     */
    private void visitImport(DetailAST importAst) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (!isStarImport(importAst)) {</span>
<span class="fc" id="L293">            final String canonicalName = getImportedTypeCanonicalName(importAst);</span>
<span class="fc" id="L294">            extendIllegalClassNamesWithShortName(canonicalName);</span>
        }
<span class="fc" id="L296">    }</span>

    /**
     * Checks if current import is star import. E.g.:
     * &lt;p&gt;
     * {@code
     * import java.util.*;
     * }
     * &lt;/p&gt;
     * @param importAst {@link TokenTypes#IMPORT Import}
     * @return true if it is star import
     */
    private static boolean isStarImport(DetailAST importAst) {
<span class="fc" id="L309">        boolean result = false;</span>
<span class="fc" id="L310">        DetailAST toVisit = importAst;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        while (toVisit != null) {</span>
<span class="fc" id="L312">            toVisit = getNextSubTreeNode(toVisit, importAst);</span>
<span class="fc bfc" id="L313" title="All 4 branches covered.">            if (toVisit != null &amp;&amp; toVisit.getType() == TokenTypes.STAR) {</span>
<span class="fc" id="L314">                result = true;</span>
<span class="fc" id="L315">                break;</span>
            }
        }
<span class="fc" id="L318">        return result;</span>
    }

    /**
     * Checks type of given method, parameter or variable.
     * @param ast node to check.
     */
    private void checkClassName(DetailAST ast) {
<span class="fc" id="L326">        final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);</span>
<span class="fc" id="L327">        final FullIdent ident = FullIdent.createFullIdent(type.getFirstChild());</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (isMatchingClassName(ident.getText())) {</span>
<span class="fc" id="L330">            log(ident.getLineNo(), ident.getColumnNo(),</span>
<span class="fc" id="L331">                MSG_KEY, ident.getText());</span>
        }
<span class="fc" id="L333">    }</span>

    /**
     * Returns true if given class name is one of illegal classes or else false.
     * @param className class name to check.
     * @return true if given class name is one of illegal classes
     *         or if it matches to abstract class names pattern.
     */
    private boolean isMatchingClassName(String className) {
<span class="fc" id="L342">        final String shortName = className.substring(className.lastIndexOf('.') + 1);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        return illegalClassNames.contains(className)</span>
<span class="fc bfc" id="L344" title="All 4 branches covered.">                || illegalShortClassNames.contains(shortName)</span>
                || validateAbstractClassNames
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    &amp;&amp; !legalAbstractClassNames.contains(className)</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                    &amp;&amp; format.matcher(className).find();</span>
    }

    /**
     * Extends illegal class names set via imported short type name.
     * @param canonicalName
     *  &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7&quot;&gt;
     *  Canonical&lt;/a&gt; name of imported type.
     */
    private void extendIllegalClassNamesWithShortName(String canonicalName) {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (illegalClassNames.contains(canonicalName)) {</span>
<span class="fc" id="L358">            final String shortName = canonicalName</span>
<span class="fc" id="L359">                .substring(canonicalName.lastIndexOf('.') + 1);</span>
<span class="fc" id="L360">            illegalShortClassNames.add(shortName);</span>
        }
<span class="fc" id="L362">    }</span>

    /**
     * Gets imported type's
     * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7&quot;&gt;
     *  canonical name&lt;/a&gt;.
     * @param importAst {@link TokenTypes#IMPORT Import}
     * @return Imported canonical type's name.
     */
    private static String getImportedTypeCanonicalName(DetailAST importAst) {
<span class="fc" id="L372">        final StringBuilder canonicalNameBuilder = new StringBuilder(256);</span>
<span class="fc" id="L373">        DetailAST toVisit = importAst;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        while (toVisit != null) {</span>
<span class="fc" id="L375">            toVisit = getNextSubTreeNode(toVisit, importAst);</span>
<span class="fc bfc" id="L376" title="All 4 branches covered.">            if (toVisit != null &amp;&amp; toVisit.getType() == TokenTypes.IDENT) {</span>
<span class="fc" id="L377">                canonicalNameBuilder.append(toVisit.getText());</span>
<span class="fc" id="L378">                final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit, importAst);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                if (nextSubTreeNode.getType() != TokenTypes.SEMI) {</span>
<span class="fc" id="L380">                    canonicalNameBuilder.append('.');</span>
                }
<span class="fc" id="L382">            }</span>
        }
<span class="fc" id="L384">        return canonicalNameBuilder.toString();</span>
    }

    /**
     * Gets the next node of a syntactical tree (child of a current node or
     * sibling of a current node, or sibling of a parent of a current node).
     * @param currentNodeAst Current node in considering
     * @param subTreeRootAst SubTree root
     * @return Current node after bypassing, if current node reached the root of a subtree
     *        method returns null
     */
    private static DetailAST
        getNextSubTreeNode(DetailAST currentNodeAst, DetailAST subTreeRootAst) {
<span class="fc" id="L397">        DetailAST currentNode = currentNodeAst;</span>
<span class="fc" id="L398">        DetailAST toVisitAst = currentNode.getFirstChild();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        while (toVisitAst == null) {</span>
<span class="fc" id="L400">            toVisitAst = currentNode.getNextSibling();</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (toVisitAst == null) {</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">                if (currentNode.getParent().equals(subTreeRootAst)) {</span>
<span class="fc" id="L403">                    break;</span>
                }
<span class="fc" id="L405">                currentNode = currentNode.getParent();</span>
            }
        }
<span class="fc" id="L408">        return toVisitAst;</span>
    }

    /**
     * Returns true if method has to be checked or false.
     * @param ast method def to check.
     * @return true if we should check this method.
     */
    private boolean isCheckedMethod(DetailAST ast) {
<span class="fc" id="L417">        final String methodName =</span>
<span class="fc" id="L418">            ast.findFirstToken(TokenTypes.IDENT).getText();</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        return !ignoredMethodNames.contains(methodName);</span>
    }

    /**
     * Set the list of illegal variable types.
     * @param classNames array of illegal variable types
     * @noinspection WeakerAccess
     */
    public void setIllegalClassNames(String... classNames) {
<span class="fc" id="L428">        illegalClassNames.clear();</span>
<span class="fc" id="L429">        Collections.addAll(illegalClassNames, classNames);</span>
<span class="fc" id="L430">    }</span>

    /**
     * Set the list of ignore method names.
     * @param methodNames array of ignored method names
     * @noinspection WeakerAccess
     */
    public void setIgnoredMethodNames(String... methodNames) {
<span class="fc" id="L438">        ignoredMethodNames.clear();</span>
<span class="fc" id="L439">        Collections.addAll(ignoredMethodNames, methodNames);</span>
<span class="fc" id="L440">    }</span>

    /**
     * Set the list of legal abstract class names.
     * @param classNames array of legal abstract class names
     * @noinspection WeakerAccess
     */
    public void setLegalAbstractClassNames(String... classNames) {
<span class="fc" id="L448">        Collections.addAll(legalAbstractClassNames, classNames);</span>
<span class="fc" id="L449">    }</span>

    /**
     * Set the list of member modifiers (of methods and fields) which should be checked.
     * @param modifiers String contains modifiers.
     */
    public void setMemberModifiers(String modifiers) {
<span class="fc" id="L456">        final List&lt;Integer&gt; modifiersList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (String modifier : modifiers.split(&quot;,&quot;)) {</span>
<span class="fc" id="L458">            modifiersList.add(TokenUtil.getTokenId(modifier.trim()));</span>
        }
<span class="fc" id="L460">        memberModifiers = modifiersList;</span>
<span class="fc" id="L461">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>